Id,Genre,Title,Contents,Created at,Updated at
1,パソコンの基本操作,Macのショートカットキー,"# Macのショートカットキー
パソコンになれてないなら、まずはショートカットキーから使えるようにしていきましょう。ここにあげてあるショートカットキーを使えないと、プログラミングの学習効率は全く上がらないです。

プログラマーなるなら必須中の必須なので、ぜひ使いこなせるようにしてください。絶対にこれだけは覚えて！というショートカットキーは以下の通り。

上書き保存

```
command + s
```

コピー

```
command + c
```

カット

```
command + x
```

ペースト

```
command + v
```

更新

```
command + r
```

新しいウインドウを開く（ブラウザ、テキストエディタなど）

```
command + t
```

新規で開く（ブラウザ、テキストエディタなど）

```
command + n
```

アプリの切り替え

```
shift + tab
```

# まとめ
パソコンの操作スピードを上げるためにも、ショートカットキーを活用することはとても重要になってきます。特に、コピー&ペーストや上書き保存は、ショートカットキーを使用するのとそうでないのでは大きな差が出てくるので、ぜひ使えるようにしておきましょう。
",2018-11-07 02:04:25 UTC,2018-11-07 04:34:59 UTC
2,パソコンの基本操作,Linuxコマンド,"# Linuxコマンド
Linuxコマンドは、Ruby on Railsアプリを開発するときにもよく使うコマンドです。Macでプログラミングを学ぶ際に、このLinuxコマンドの知識が必須となりますので、一つ一つ確認していきましょう。

また、Linuxコマンドにはたくさんの種類がありますが、こちらではよく使用するコマンドを抽出して載せるようにします。上に書いてあるものから順に覚えて行くと無駄なく学習することができます。

## cd
ディレクトリ間を移動するときのコマンドは以下のようになります。 `directory_name` には、自分が移動したいディレクトリの名前を入れましょう。

```
cd directory_name
```

ためしに、 `cd` コマンドを利用して `desktop` へ移動してみましょう。

```
cd desktop
```

コマンドを実行した後のターミナルの表示に `desktop` という表示が含まれていれば移動は成功です。ターミナルでは、このように `cd` コマンドを利用してパソコン内を移動します。非常によく利用するコマンドなので、是非使えるようにしておきましょう。

```
MacBook-Pro-2:desktop your_name$
```


## ls
現在操作を行なっているディレクトリにあるファイルや、他のディレクトリを一覧表示するためには`ls`コマンドを実行します。 `cd` コマンドでディレクトリ間の移動を行い、 `ls` コマンドで操作したいディレクトリやファイルが存在するかどうかを調べるというのがよくある使い方です。

```
ls
```

## pwd
ターミナル上で操作対象となっているディレクトリの場所を表示するコマンドです。これを実行すると、ディレクトリのパスが表示されます。

```
pwd
```

実行結果

```
/Users/yoshito/desktop
```

## touch
新しいファイルを作成するときには`touch`コマンドを使用します。`directory_name`には自分が作成したいファイル名を拡張子を含めて指定します。

```
touch file_name
```

例

```
touch sample.rb
```

## mkdir
新しいディレクトリを作成するときは`mkdir`コマンドを使用します。`directory_name`には自分が作成したいディレクトリ名を指定します。

```
mkdir directory_name
```

例

```
mkdir sample
```

# まとめ
Linuxコマンドは、Macの操作をする上ではとても重要なコマンドとなります。プログラミングをやるときにも、これらのコマンドはよく使用するのでぜひ使えるようにしてみてください。",2018-11-07 04:34:10 UTC,2018-11-07 04:35:33 UTC
3,パソコンの基本操作,Slackを使用したいろんなマークダウン記法,"# Slackを使用したいろんなマークダウン記法
Slackを使いこなすと、プログラミング学習の効率もぐんと上がる（特に質問の仕方が上手くなる）ので、ぜひマークダウン記法を利用してみてください！


|No.|記入方法|用途|
|---|---|---|
|1|@hoge|hogeさん、あるいは hoge グループあてのコメントになる|
|2|#hoge|	チャンネル　hoge へのリンクになる|
|3| \`サンプルコード \`|ボーダーで囲まれ、文字色赤、背景灰色になる|
|4| \`\`\` サンプルコード \`\`\` |ボーダーで囲まれ、 \`\`\` で発言を開始すると再び \`\`\` が来るまでは改行しても送信しない|
|5|>引用文|引用表現にする|
|6|>>>引用文|改行含めた段落全体を引用表現にする|
|7|\_slack_|文字をイタリックにする|
|8|\*slack*|文字をボールドにする|
|9|\~slack~|文字をストライク（取り消し線）にする|


No.3, 4 の記法を使用した時の表示は以下のようになります。

`No.3の書き方：1行のコードを書く場合`

```
No.4の書き方
複数行のコードを書く場合
```

# まとめ
Slackにおいてマークダウンを使用するとコミュニケーション効率が圧倒的に上がるので、ぜひ活用して見てください。",2018-11-07 04:36:00 UTC,2018-12-04 06:38:19 UTC
4,パソコンの基本操作,Atomの便利な使い方,"# Atomの基本的な使い方
`Atom`とは、フリーで使えるテキストエディタのことで、初心者向けのエディタの1つとして利用されます。

様々なパッケージが用意され、カスタマイズも簡単に行えるので、何を使っていいのかわからないのであれば、`Atom`を使用するといいでしょう。

[ダウンロード](https://atom.io/)

それでは早速、`Atom`のオススメの使い方を見ていきましょう。

## 日本語のメニューを表示する

1. 左上メニュー Atom \> Preferences を選択
2. +Install
3. 検索ボックスに Japanese-menu と入力
4. Packages ボタンを押す
5. 検索結果に出てきた Japanese-menu をインストール

## 全角、半角スペースやタブの可視化

1. ウィンドウ左上のFileを選択
2. Preferences->Editor->Show Invisiblesのチェックボックスをオン
3. 半角スペースやタブが可視化

## 便利なショートカットキー

|キー|用途|
|---|---|
|command + f|ファイル内の文字列検索・置換|
|command + shift + f|プロジェクト内の文字列検索・置換|
|commad + p|プロジェクト内のファイル検索|
|command + n|新しくファイルを開く|
|command + w|アクティブなタブを閉じる|
|command + k + w|開いているタブを全部閉じる|
|command + shift + t|閉じたタブを復活する|

# まとめ
テキストエディタの便利なパッケージやショートカットキーを使いこなすと作業が早くなります。

プログラマーとしての作業スピードを高めるためにも、テキストエディタの基本的な機能を確認してみてください。知れば知るほど、自分が楽になります。",2018-11-07 04:37:25 UTC,2018-11-07 04:38:01 UTC
5,パソコンの基本操作,超便利なMarkdownの基本,"# Markdownの基本
Markdownは、プログラミングのコードをまとめる上でとても役に立つものです。

普通、プログラミングを学んでいるときにノウハウをまとめるのはプログラマーなら常識なのですが、それをただテキストでまとめるだけだとめちゃくちゃ効率が悪いです。

なぜなら、コードと、そのコードに対応する説明の区別ができなくなってしまい、かえって理解するのが難しくなってしまうためです。これでは、せっかくノウハウをまとめても無駄に終わってしまいます。

例えば、Rubyのコードを以下のようにMarkdownを使わず普通にまとめてみたとしましょう。

---

ターミナルに「Hello World」を出力する

puts ""hello world""

putsは右側に書かれたもの（引数）をターミナルに出力させるためのメソッドです

---

上記のようにまとめても、どこがRubyのコードで、どこがそのコードに対する説明なのかがかなりわかりづらいです。

これが１〜２行程度ならいいのですが、実際に勉強をたくさんしていると、どんどんノウハウはたまり、その量は膨大なものになってきます。

しかし、それがMarkdownを使用すると以下のようにまとめることができます。

---
ターミナルに`Hello World`を出力する

```ruby
# puts : ターミナルに文字や数字などの情報を出力する
puts ""hello world""
```

`puts`は右側に書かれたもの（引数）をターミナルに出力させるためのメソッドです

---

どうでしょう？

かなりコードが見やすくなったのではないでしょうか？？

上記のようにプログラミングのコードを色付き（シンタックスハイライト）でまとめるには、以下のような記述をします。

---

ターミナルに\`Hello World\`を出力する

\```ruby

\# puts : ターミナルに文字や数字などの情報を出力する

puts ""hello world""

\```

\`puts\`は右側に書かれたもの（引数）をターミナルに出力させるためのメソッドです

---

このように、Markdownは特定の記号を使用することによって、プログラミングのコードを綺麗にまとめることができます。

これを使用すると、爆速でノウハウをまとめられるようになるので、ぜひご活用ください。

ちなみに、当サロンの教材もMarkdownを利用してまとめています。

|記入方法|用途|
|---|---|
|#|大見出し（HTMLのH1に相当する）|
|##|中見出し（HTMLのH2に相当する）|
|###|小見出し（HTMLのH3に相当する）|
|\---|水平線（HTMLのhrに相当）|
|>引用文|引用表現にする|
|>>>引用文|改行含めた段落全体を引用表現にする|
|\`サンプルコード`|1行のコードをボーダーで囲み、背景を灰色にする|
|\``` サンプルコード ```|複数行のコードをボーダーで囲み、背景を灰色にする|
|\_hoge_|文字（hogeの部分）をイタリックにする|
|\*hoge*|文字（hogeの部分）をボールドにする|
|\~hoge~|文字（hogeの部分）をストライク（取り消し線）にする|

そしてなんと！！！

↑のテーブルもMarkdownで作ることができます笑

テーブルの作成は以下のように記述します。

---

\|記入方法|用途|

\|---|---|

\|#|大見出し（HTMLのH1に相当する）|

\|##|中見出し（HTMLのH2に相当する）|

\|###|小見出し（HTMLのH3に相当する）|

---

これがあの綺麗なテーブルになるなんて信じられないですよね。
でも、Markdown使えば簡単にできちゃいます。

# まとめ
テキストでプログラミングのノウハウをまとめる上で、Markdownは本当に最強です。

また、Markdown で作成したコンテンツに関しては、HTML、ワードファイル、PDFに変換することができ、コンテンツの横展開につながります。

これを利用して独自のコンテンツを作成すれば、あなたも自分のサービスで収益を上げることがかなり楽になりますよ。
生産性がめちゃくちゃ高くなるので、ぜひ活用してみてください。",2018-11-07 04:38:45 UTC,2018-11-07 04:38:45 UTC
6,パソコンの基本操作,現場でやったらあかんこと,"# 現場でやったらあかんこと一覧
こちらは、現場でやったらあかんことをどんどん追加していきます。
神里の失敗経験も書きますよ！踏み台にしてね！

# Githubリポジトリのmasterにプッシュ
Githubのリポジトリであるリモートリポジトリの`master`にプッシュすると、プルリクやコードレビューをすっとばして`master`に反映させることになります。

つまり、大事なプロダクトのソースコードが一瞬で書き換えられてしまうということです。

もちろん復旧させる方法はありますが、絶対にやらないように意識しておきましょう！

# bundle update ダメゼッタイ
gemをインストールする際、`bundle install`と`bundle update`があるのですが、`bundle update`は`Gemfile.lock`に書かれている全てのgemのバージョンを書き換えてしまいます。

そのため、バージョンによる不具合が発生してしまい、サービスが動かなくなってしまいます。
影響範囲がものすごく大きいので、現場では絶対にやめましょう！
めっちゃ怒られます！

# AWSへのsshの接続が途中で切れる
これは僕が死にかけたやつです。
40万件のCSVデータをAWSのインスタンスにインポートしている最中にssh接続が切れ、

- インポートが途中で止まる
- タスクを強制終了できない
- サービスがブラウザに表示されない（サーバーが止まる）

という地獄の状態になりました。
これを防ぐためには、ssh接続がタイムアウトしないように設定する必要があります。

以下、sshの接続設定手順。

まずは、`.ssh`という隠しディレクトリの中に移動します。

```
 cd ~/.ssh/
```

`vim`で`config`ファイルを開きます。

```
vi config
```

モードを聞かれるので`e`を入力します。

```
e
```

`i`を押してINSERTモードに切り替え`config`を以下のように編集します。

```
Host *
    ServerAliveInterval 15
    ServerAliveCountMax 10
```

編集が終了したら、キーボード左上の`esc`を押して`:wq`で上書き保存して終了します。

これで設定は完了です。",2018-11-07 04:39:29 UTC,2018-11-07 04:39:29 UTC
7,Git,Gitの基本,"# Gitとは
Gitは、プログラムのソースコードなどの変更履歴を記録・追跡するためのバージョン管理システムです。バージョン管理とは、その名の通り、複数存在するソースコードのバージョンを管理するためのものです。このGitを使用することによって、変更履歴をさかのぼってソースコードを元の状態に戻す事ができ、複数人での共同開発も可能になります。

チームでの共同開発をする上で、もはやGitは欠かせない存在となっています。プログラマーというとコードを書いているイメージがあるかと思いますが、それ以前にGitなどのバージョン管理ツールが無ければ仕事になりません。ぜひ、ここで基礎を押さえておきましょう。

## Gitにおける開発の流れ
まずは基本的な用語から押さえておきましょう。Gitがバージョン管理下におく場所を「リポジトリ」と言います。リポジトリには「ローカルリポジトリ」と「リモートリポジトリ」があります。ローカルリポジトリは自分のパソコン内にあるリポジトリ、リモートリポジトリはネット上にあるリポジトリと覚えておきましょう。リモートリポジトリに関しては、後ほど詳しくご説明いたします。

ユーザが変更の履歴を保存することをコミット（commit）と言います。これはGitの持つ機能の中でも特によく使用するので、ぜひ覚えておいてください。コミットは実行した順番で記録されるので、時系列に沿って変更履歴を追う事ができます。そのため、過去にどういう変更を行ったのかを簡単に確認する事ができるのです。

また、コミットをする際にはコミットメッセージという形でメモを残す事ができます。例えば、「デザインの変更をしました」とか「データベースへの登録処理を追加しました」といったメモを残す事ができるというわけです。それによって、より変更履歴の理解が容易になります。

複数人での開発を行う際は、この「コミット」と「コミットメッセージ」を利用し、誰がみても理解できるような変更履歴を作成し、任意の履歴に遡ることができるよう心がけましょう。

## gitの構成
詳細な説明に入る前に、まずはGitがファイルの状態を保存する場所についてご説明します。実は、Gitにはファイルを保存するための場所がいくつかあります。その構成は以下の通りです。

1. ワーキングツリー（今作業しているファイルのある場所）
2. インデックス（コミットするためのファイルを登録する場所）
3. ローカルリポジトリ（リモートリポジトリに変更内容を送信するための場所）
4. リモートリポジトリ（複数人でファイルを共有するための場所）

## 同時並行で複数の開発を可能にする機能
Gitには、複数の開発を同時並行することができる機能があります。例えば、Aさんはデータの登録を行う処理を実装し、Bさんはデータの表示形式を綺麗にするという実装をするとします。そのとき、2人で同じファイルを編集すると、とても効率が悪くなります。その問題を解決するための機能が「ブランチ」です。ブランチとは、文字通り開発を枝分かれさせる機能のことで、これを使用することによってAさんとBさんの開発を別々のものとして扱うことができます。

例）
Aさん　→ ブランチA
Bさん　→ ブランチB

## ローカルリポジトリとリモートリポジトリ
前述でGitのバージョン管理下にある場所をリポジトリというというお話をしました。その中でも、ネットを介してどこからでも利用できるようにしたリポジトリのことをリモートリポジトリと言います。それとは逆に、自分のパソコン内にあるリポジトリのことろローカルリポジトリと言います。複数人での開発を行うときは、リモートリポジトリを複数のプログラマーで共有し、そのリモートリポジトリのクローンをそれぞれのプログラマーがローカルリポジトリにコピーして開発を行うというスタイルになります。これによって、１つのプロジェクトを複数人で開発することが可能になるわけです。

## バージョン管理の流れ
Gitでのバージョン管理は基本的に以下のような流れになります。

- ローカルリポジトリの作成（git init）
- 変更ファイルをインデックスにあげる（git add）
- 変更履歴を保存する（git commit）

## 今回使用するサンプル
今回は、Hello World!!と表示する単純なHTMLファイルを利用して、Gitの使い方を学んでいきましょう。`git_sample`というディレクトリを作成し、テキストエディタで`git_sample.html`というファイルを作成しましょう。

まずは、サンプルファイルを置くための`git_sample`ディレクトリをターミナルから作成しましょう。

```
mkdir git_sample
```

ディレクトリが作成できたら、cdコマンドで`git_sample`ディレクトリに移動しましょう。

```
cd git_sample
```

ディレクトリに移動できたら、`git_sample.html`を作成します。ファイルに関しては、テキストエディタから作成してもいいのですが、ターミナルから作成することも可能です。その際は、`touch`コマンドを使用します。`git_sample.html`という名前のファイルを作成する場合は、以下のコマンドを実行しましょう。

```
touch git_sample.html
```

これで、Gitの練習をする準備が整いました。それではさっそく、Gitコマンドについて学んでいきましょう。

## Gitをインストールする
Gitをパソコンで使用できるようにするためには、まずはインストールを行わなければいけません。

そのGitをインストールするためには、Homebrewというパッケージ管理ツールを使用すると楽なので、まずはHomebrewからインストールしましょう。

以下のコマンドをターミナルにコピー&ペーストして実行してください。それだけで、Homebrewがインストールできます。

```
/usr/bin/ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
```

Homebrewのインストールが終わったら、以下のコマンドをターミナルに入力し、Homebrewを使用してGitをインストールします。

```
brew install git
```

インストールが完了したら、いよいよGitを利用したバージョン管理の方法について学んでいきます。なんども基礎を繰り返し、バージョン管理のスキルをしっかりと身につけていきましょう！

## ローカルリポジトリを作る
cdコマンドを利用してローカルリポジトリを作成したいディレクトリに移動できたら、`git init`というコマンドを実行します。このコマンドで、ディレクトリ内に中身が空のローカルリポジトリを作成します。また、すでにリポジトリが存在している場合には、再度`git init`を実行する必要はありません。

```
git init
```

`ls`コマンドを入力し、gitのリポジトリができていることを確認しましょう。以下のように.Gitというディレクトリが作成されて入れば成功です。

```
ls -la
```


## サンプルを編集する
それでは、先ほど作成した`git_sample.html`の内容を変更しましょう。以下のコードを追加してください。

```
<h1>Hello World!!</h1>
```

以上のように変更できたら、次はその変更履歴を`Git`を使用して保存します。

## ファイルをインデックスに登録する
`git init`実行後、現在作成したファイルの変更履歴を保存するために`git add .`を実行します。このコマンドは、現在開発しているプロジェクトの中で変更があったファイルを見つけてインデックスに上げ、変更履歴を保存するための準備をしてくれます。要するに、「変更した全てのファイル」を「Gitによってバージョン管理するための対象」に入れるということです。それでは、`git add .`を実行しましょう。

```
git add .
```

ちなみに、`git add .`は変更したファイルをまとめてインデックスにあげるためのコマンドになります。そのほかにも、特定のファイルのみをインデックスに上げるコマンドもあります。その場合は、`git add ファイル名`コマンドを実行します。

例） sample.rbというファイルのみをインデックスに上げる場合のコマンド

```
git add sample.rb
```

## 変更履歴を保存する
変更履歴を保存するには、`commit`というコマンドを実行します。このコマンドを実行すると、ローカルリポジトリの変更内容を保存します。

また、`commit`を実行する際には`git add`において変更済みのファイルがインデックスにあることが必須となります。もし変更済みのファイルがインデックスにない場合は、`commit`するものが無いというメッセージが表示されます。

```
nothing to commit, working tree clean
```

`commit`を実行する際は、以下のコマンドを入力します。`-m`や`--message`オプションをつけることによって、コミットに対するコメントを残すことができます。これにより、各コミットにおいてどのような変更が行われたのかを把握しやすくすることができます。

```
git commit -m ""init commit""
```

## コミットまでの流れのおさらい
それでは、ファイルを変更してからコミットするまでの流れを改めておさらいしましょう。

先ほど作成した`git_sample.html`の内容を以下のように変更しましょう。

```
<h1>Good morning!!</h1>
```

変更したファイルをインデックスに登録します。

```
git add .
```

インデックスに登録したファイルをコミットします。

```
git commit -m ""change message""
```

これで、ファイルを変更してからコミットまでの一連の流れが終了です。 `git add` を実行してから `git commit` という流れをなんども繰り返して体に覚えさせるようにしましょう。

## 変更履歴のメッセージを修正する
コミットメッセージを修正したい時には、以下のコマンドを実行します。

```
git rebase -i HEAD^
```

それでは、過去のコミットメッセージを変更してみましょう。まずは、過去のコミットメッセージを確認してください。

```
git log
```

そうすると、過去のコミット一覧が表示され、それに対応するコミットメッセージも確認できます。


```
change message
```

今回は、`change message`というメッセージを`change hello to good morning`に変更しましょう。それではさっそく、以下のコマンドを実行してください。

```
git rebase -i HEAD^
```

そうすると、以下のような画面が表示されます。

```
pick 65e1b59 change message

# Rebase d9a2c59..65e1b59 onto d9a2c59 (1 command)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
~
~
~
""~/git_sample/.git/rebase-merge/git-rebase-todo"" 20L, 680C
```

その表示の中で、一番上に書かれている`pick`の部分を`r`に変更するとコミットメッセージを編集することができます。その際、`i`を押して表示を`INSERT`モードに切り替えてください。そうすると、以下のように画面の一覧下に`INSERT`という文字が表示されます

```
pick 65e1b59 change message

# Rebase d9a2c59..65e1b59 onto d9a2c59 (1 command)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
~
~
~
-- INSERT --
```

`INSERT`が表示されたら、`pick`の部分を`r`に書き換えましょう。

```
r 65e1b59 change message

# Rebase d9a2c59..65e1b59 onto d9a2c59 (1 command)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
~
~
~
""~/git_sample/.git/rebase-merge/git-rebase-todo"" 20L, 680C
```

書き換えられたら、キーボードの左上にある`esc`を押し、`:wq`で上書き保存します。そうすると、次にコミットメッセージが表示されます。

```
chnage message

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Mon Sep 10 12:58:07 2018 +0900
#
# interactive rebase in progress; onto d9a2c59
# Last command done (1 command done):
#    r 65e1b59 change hello to good morning
# No commands remaining.
# You are currently editing a commit while rebasing branch 'master' on 'd9a2c59'.
#
# Changes to be committed:
#       renamed:    .git_sample.rb.swp -> .git_sample.rb.swo
#       modified:   git_sample.rb
#
~
~
~
~
~
~
""~/git_sample/.git/COMMIT_EDITMSG"" 17L, 563C
```

コミットメッセージが確認できたら、`i`をクリックして`INSERT`モードに切り替え、コミットメッセージを変更します。

```
change hello to good morning

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Mon Sep 10 12:58:07 2018 +0900
#
# interactive rebase in progress; onto d9a2c59
# Last command done (1 command done):
#    r 65e1b59 change hello to good morning
# No commands remaining.
# You are currently editing a commit while rebasing branch 'master' on 'd9a2c59'.
#
# Changes to be committed:
#       renamed:    .git_sample.rb.swp -> .git_sample.rb.swo
#       modified:   git_sample.rb
#
~
~
~
~
~
~
""~/git_sample/.git/COMMIT_EDITMSG"" 17L, 563C
```

メッセージが変更できたら、`esc`を押し、`:wq`で変更内容を保存しましょう。そのあと、以下のコマンドを入力してコミットメッセージが変更されていることを確認してください。

以上で、コミットメッセージの変更は終了です。

## ブランチを作成する
ブランチとは、複数の開発を同時並行して行うために必要な仕組みです。変更履歴の管理を分岐させることによって、各プログラマーで別々の機能を実装する事ができます。「ブランチ」という名前の通り、開発を枝分かれさせるという事ですね。そのブランチを作成するには、以下のコマンドを実行します。

ブランチは、他のブランチに合体（マージ）させる事で、一つにまとめる事ができます。`master`と呼ばれるブランチが存在し、開発用に分岐させた他のブランチは、最終的にこの`master`にマージさせるというのが、一般的な開発の流れです。

```
git branch ブランチ名
```

`git branch`の後ろに任意のブランチ名をつける事によって、その名前で新しいブランチを作り出す事ができます。例えば、`sample`という名前のブランチを作成したいときは、以下のようにコマンドを入力します。

```
git branch sample
```

現在存在するブランチを確認したい場合は、`git branch`を実行するだけで大丈夫です。

```
git branch
```

新しくブランチを作成し切り替えるコマンドは以下の通りです。

```
git checkout -b sample
```

## ブランチを切り替える
ブランチが作成できたら、つぎにその切り替え方を学んでいきましょう。現在、`git branch`を実行すると以下のような表示がされるかと思います。

```
* sample
  master
```

その状態で、`git_sample.html`の内容を以下のように編集してみましょう。

```
<h1>こんにちは！！</h1>
```

上記のようにコードを変更できたら、次はその変更履歴を保存します。これまでの一連の流れを、ここで改めて確認しましょう。

変更したファイルをインデックスにあげる

```
git add .
```

変更履歴を保存する

```
git commit -m ""changed english to japanese""
```

変更履歴が保存できたら、

## ブランチをマージする（ローカルで完結）
開発が完了したブランチを他のブランチに合体することをマージと言います。今回は、`sample`ブランチから`master`ブランチへマージする例を見て見ましょう。

まず、今存在しているブランチを確かめます。

```
git branch
```

出力結果

```
* sample
  master
```

`sample`ブランチから、`master`ブランチへと切り替えます。その際、使用するコマンドは`checkout`です。

```
git checkout master
```

次に、`merge` コマンドを利用して、 `sample` ブランチを `master` にマージさせます。これでマージは完了です。

```
git merge sample
```

ブランチを消すときは以下のコマンドを実行します。マージが終わったらいらないブランチは削除するようにしましょう。

```
git branch -d sample
```

# まとめ
以上でGitの基本操作は終わりです。

基本といっても、初心者の方にはとても難易度の高い作業であり、わからない部分があって当然です。

不明点がある場合はすぐに神里に聞いてください。また、この項目をなんども繰り返してちょっとずつ理解を深めていってください。

プログラミングは一回やれば身につくというものではありません。しかし、何度もやると以前は1時間かかったものが一瞬で終わるようになることもよくあります。

なので、ぜひご自身の成長を楽しみながら続けていっていただけると幸いです。

お疲れ様でした！",2018-11-07 04:40:42 UTC,2018-11-07 04:40:42 UTC
8,Git,Gitで使用するテキストエディタ、Vimの使い方,"# Vim
Vimとは、かなり歴史のあるテキストエディタです。初心者からすると難しそうな印象ですが、コアなユーザーの多いエディタです。

# Vimの使い方
Vimはモードを使い分けることによって色々な操作ができるようになっています。

|操作|入力キー|
|---|---|
|カーソルを↑に移動|k|
|カーソルを↓に移動|j|
|カーソルを←に移動|h|
|カーソルを→に移動|l|
|一文字削除|x|
|インサートモードへ|i|
|次行を新規行として挿入してインサートモードへ|o|
|現在行に新しい行を追加してインサートモードへ|O|
|インサートモードからノーマルモードへ	|esc|

以上のような操作を使い分けて、行いたい処理を実行します。

例えば、コードの編集を行いたいときは`i`でインサートモードに切り替え、編集が終わったら`esc`でノーマルモードに戻すわけです。

# 保存や終了に関する操作
Vimでは、ファイルを編集した後の操作にもコマンドを使用します。

|操作|入力キー|
|---|---|
|上書き保存|:w|
|名前をつけて保存|:w ファイル名|
|編集終了|:q|
|保存して終了|:wq または :x|
|ファイルを開く|:e ファイル名|

ファイルを編集した場合は、一度`esc`を押してインサートモードからノーマルモードへ切り替えて行いましょう。

その後、`:w`を入力すると上書き保存ができ、`:q`通すとVimを終了させることができます。

ちなみに、`:wq`を入力すると上書き保存と終了を一度に行うことができます。

# まとめ
Vimは使い方にちょっと癖がありますが、慣れれば普段のテキストエディタと同じように使えます。人によっては、Vimの方が圧倒的にいいという人もいるくらいです。

AWSやGitでも、Vimを使用してファイルを編集することがあるので、基本的な使い方はマスターしておきましょう。現場でも、きっと使う場面が出てくるはずですよ。
",2018-11-07 04:41:39 UTC,2018-11-07 04:41:39 UTC
9,Git,Gitコマンド一覧,"# Gitコマンド一覧
Gitに関して、よく使うコマンドを一覧にしています。復習にお役立てください。

Gitでのバージョン管理を開始する

```
git init
```

変更したファイルをインデックスにあげる

```
git add .
```

特定のファイルのインデックスへの追加を取り消す

```
git reset HEAD config/database.yml
```

変更履歴を保存

```
git commit -m ""message""
```

コミットの履歴を確認

```
git log
```

変更内容を一時的に退避（コミットする前の変更内容）

```
git stash
```

退避した変更を復元する

```
git stash pop
```

変更したファイルをリモートリポジトリに反映

```
git push origin remote_url
```

リモートリポジトリの状態を無視して強制プッシュ

```
git push -f origin remote_url
```

ブランチの確認

```
git branch
```

ブランチの切り替え

```
git checkout branch_name
```

ブランチを新規作成して切り替えまでを一気にやる

```
git checkout -b new_branch_name
```

ブランチ名の変更

```
git branch -m new_branch_name
```

過去のコミットの状態にファイルを戻す（1つ前に戻す）

```
git checkout HEAD^
```

過去のコミットの状態にファイルを戻す（3つ前に戻す）

```
git checkout HEAD^^^
```

リポジトリをクローンする

```
git clone github_url
```

前回のコミットとの変更点の差分を確認する

```
git diff HEAD^
```

2つ前のコミットとの変更点の差分を確認する

```
git diff HEAD^^
```

リモートリポジトリの変更内容をローカルリポジトリに反映させる（リモートリポジトリにあるブランチがローカルリポジトリに反映される）

```
git fetch
```

リモートリポジトリのブランチを確認する

```
git branch -a
```

HEADにマージしたローカルリポジトリのブランチを消す

```
git branch --delete branch_name
```

マージの有無にかかわらずローカルリポジトリのブランチを消す

```
git branch -D branch_name
```

過去のコミット3つ分をまとめる（コミットメッセージの変更もできる）

```
git rebase -i HEAD^^^
```

ローカルの変更内容を取り消す（新規追加したファイルは削除されない）

```
git checkout .
```",2018-11-07 04:42:18 UTC,2018-11-07 04:42:18 UTC
10,Git,GitとGithubを利用した共同開発,"# GitとGithubを利用した共同開発
GitとGithubは、共同開発を可能にするためのツールとして様々な現場で採用されています。今回は、それをできるだけスムーズに行うためのコツを書いて見ました。「Gitのコマンドを学んだけど、それをどう活かしていいかわからない」と考えている初心者は、こちらの記事を読んでやり方をマスターしていってください。コツを掴めば簡単です。心配せずいきましょう！

## リモートリポジトリをクローンする
まず、共同開発を行うにはリモートリポジトリを自分のパソコン（ローカル）にコピーしてこなければなりません。そのときに使用するのが`git clone`というコマンドです。このコマンドをターミナルから使用すると、現在ターミナルで操作している場所に、リモートリポジトリのコピーとなるディレクトリが作成されます。

```
git clone github_url
```

`github_url`には、実際に共同開発にしようするリモートリポジトリのURLを指定しましょう。そうすることで、そのURLのGithubリポジトリからディレクトリやファイルがクローンされます。

## クローンしたディレクトリに移動する
`git clone`によってリモートリポジトリのクローンができたら、次はクローンによって作成されたディレクトリに`cd`コマンドを使って移動します。

```
cd cloned_project
```

上記のコマンドの`cloned_project`は、実際にクローンを行なった際に作成されたディレクトリを指します。クローン後に作成されたディレクトリ名を`cloned_project`に置き換えてコマンドを実行しましょう。

## 開発を行う
クローンで作成されたディレクトリ内にターミナルから移動できたら、そこで初めてバージョン管理が始まります。まずは、ディレクトリをテキストエディタで立ち上げ、自分が行いたい機能の開発を行いましょう。それができたら、`git`コマンドを利用してバージョン管理を行います。

まず、色々とコードを書き加える前にブランチを作成してください。そこから、自身が行いたい開発を進めていきます。

```
git checkout -b your_branch_name
```

`your_branch_name`の部分には、あなたが作成したいブランチ名をつけてあげてください。基本的に、行いたい開発内容によってブランチ名をつけてあげるとわかりやすいでしょう。

ブランチ名の例
- add_search_funciton
- modify_import_method

ブランチが作成できたら、いよいよ機能の実装にはいります。自身が行いたい開発を進めていってください。ファイルやディレクトリを変更したら、その都度`git`コマンドを利用し、バージョン管理を行いましょう。

**自身の開発を行う際、絶対にやらなければいけないのが「動作確認」です。プルリクを送る際は、必ず正常に動作することを確認した上で送ってください。そうしないと、他のプログラマーに大きな迷惑をかけてしまうことがあります。**

また、もう１つの注意点として、`git clone`でコピーしてきたディレクトリに関しては、`git init`は必要ありません。`git add .`や`git commit`を利用してバージョン管理を行えば大丈夫です。

変更したファイルやディレクトリをインデックスにあげる場合は、以下のコマンドを実行しましょう。

```
git add .
```

変更履歴をローカルリポジトリに保存する場合は、以下のコマンドを実行しましょう。

```
git commit -m ""commit message""
```

変更内容をリモートリポジトリに反映させたい場合は、以下のコマンドを実行しましょう。

```
git push origin your_branch_name
```

## リモートリポジトリの変更内容をローカルリポジトリに反映
リモートリポジトリの変更内容をローカルリポジトリに反映させたい場合は、`git checkout master`と`git pull`を実行しましょう。

masterブランチに切り替え

```
git checkout master
```

リモートリポジトリの変更内容をローカルリポジトリに反映（マージ）

```
git pull
```

自分が作業を行いたいブランチに切り替え

```
git checkout your_branch_name
```

リモートリポジトリの変更を`pull`した`master`をマージ

```
git merge master
```

# コンフリクトの解消
コンフリクトとは、同じ箇所に対して2人以上のプログラマーが違う内容の変更を行う場合に発生するもので、変更内容が衝突することを指します。

これは、イメージしづらいので例を出してみます。余裕があれば、一緒にやってみてください。

以下が、今回の例に使用する`sample.rb`の内容です。

```ruby
puts ""Hello World!!""
```

まずは、このソースコードを管理するため、以下のコマンドを実行しましょう。

バージョン管理を開始

```
git init
```

ソースコードをインデックスに登録

```
git add .
```

変更したファイルをコミット

```
git commit -m ""first commit""
```

コミットまでできたら、Githubで新しくリポジトリを作成しましょう。リポジトリ名は`conflict_sample`にしてください。

リポジトリが作成できたら、そのリポジトリのURLをコピーしてローカルリポジトリと紐づけをします。`github_url`には、作成した`conflict_sample`のURLを入力してください。

```
git remote add origin github_url
```

次に、ローカルでソースコードを編集していきます。まずは、新しく`branch_a`を作成しましょう。

```
git checkout -b branch_a
```

ブランチが作成できたら、`sample.rb`に以下のような変更を加えましょう。

```ruby
puts ""こんにちは!!""
```

変更を加えたら、以下のコマンドを実行し、変更したファイルを保存します。

ソースコードをインデックスに登録

```
git add .
```

変更したファイルをコミット

```
git commit -m ""add branch_a""
```

コミットができたら、リモートリポジトリにプッシュします。

```
git push origin branch_a
```

リモートリポジトリにプッシュができたら、リモートリポジトリでプルリクを送ってください。それができたら、マージまでやりましょう。`branch_a`をマージできたら、ローカルでの作業に戻ります。

次は、`master`にブランチを切り替えましょう。

```
git checkout master
```

`master`に切り替えたら、新しく`branch_b`を作成します。

```
git checkout -b branch_b
```

ブランチが作成できたら、`sample.rb`に以下のような変更を加えましょう。

```ruby
puts ""おはよう!!""
```

変更を加えたら、以下のコマンドを実行し、変更したファイルを保存します。

ソースコードをインデックスに登録

```
git add .
```

変更したファイルをコミット

```
git commit -m ""add branch_b""
```

コミットができたら、リモートリポジトリにプッシュします。

```
git push origin branch_b
```

リモートリポジトリにプッシュができたら、リモートリポジトリでプルリクを送ってください。ここでコンフリクトが発生します。

```ruby
<<<<<<< branch_a
puts ""こんにちは！""
=======
puts ""おはよう!!""
>>>>>>> master
```

Aさんのプルリクエストにより、`master`の内容は`puts ""Hello World!!""`から、`puts ""おはよう!!""`に書き換わりました。

その変更を行った部分に対して、今度はBさんが`puts ""おはよう!!""`という変更を加えようとしています。

そのため、「AさんとBさんの変更内容が衝突してますよ！」という内容のコンフリクトが発生するわけです。

この解決方法は、以下の通りになります。

まず、ローカルリポジトリで`master`ブランチに切り替え、リモートリポジトリの`master`を`pull`します。

```
git pull origin master
```

その後、ブランチを`branch_b`に切り替えましょう。

```
git checkout branch_b
```

ブランチを切り替えたら、変更を反映させた`master`を`branch_b`にマージさせます。

```
git merge master
```

その後、改めて自分が行いたい変更を加えましょう。

```ruby
puts ""おはよう!!""
```

その後、リモートリポジトリに`push`してプルリクエストを送ると、今度はコンフリクトが発生せずに変更をマージすることができます。

コンフリクトを解消する練習は現場でもめちゃくちゃ役に立つので、ぜひ今回の流れを自分でも試してみてください。
現場でコンフリクトに出くわして焦る前に、解決するスキルを身につけちゃいましょう。
何事も予防が大切です！

## まとめ
以上が共同開発を行う時のコツになります。共同開発に関しては複数の人が関わる分、イレギュラーなトラブルも多いかと思います。ですが、そのトラブルも自分の血肉になることを理解し、楽しみながら乗り越えていきましょう。ここが理解できるようになると、開発はだいぶ楽になります。ぜひ、初心者のうちから慣れていってください。",2018-11-07 04:43:01 UTC,2018-11-07 04:43:01 UTC
11,Git,Gitコマンドの状況に応じた使い分け,"# Gitコマンドの状況に応じた使い分け
Gitコマンドは、その時々に応じて使い分けられるようになることが重要です。こちらでは、ただのコマンドの羅列ではなく、状況に応じてどのような対処をすべきなのかを書いていきます。緊急時の対応策としてお役立てください。

## いらないファイルをリモートリポジトリにpushしてしまった場合
本来ならpushするはずでなかったいらないファイルをリモートリポジトリにpushしてしまった場合、そのコミットをローカルリポジトリで取り消して、いらないファイルを取り除いた後にリモートリポジトリに反映させる必要があります。そのときの手順は以下の通りです。

直前のコミットのみを取り消す（インデックスにあげたファイルはそのまま）

```
git reset --soft HEAD^
```

現在の`commit`の状況を確認する

```
git status
```

実行結果を確認し、コミットの対象にしたくないファイルのパスを確認する

```
modified:   app/models/item.rb
modified:   app/views/users/index.html.erb
```

以下のコマンドを実行し、コミットしたくないファイルをインデックスから取り除く(`file_path`がコミットをしたくないファイルのパス)

```
git reset HEAD file_path
```

使用例

```
git reset HEAD app/views/users/index.html.erb
```

インデックスに上がっているファイルのみをコミット

```
git commit -m ""commit message""
```

リモートリポジトリに強制的に変更内容を反映させる（masterには絶対やらないように）

```
git push -f origin branch_name
```

## 作業するブランチを間違えて実装しちゃった場合
作業するブランチ間違ってたんだけど、気づかずにそのまま実装しちゃって、コミットするときに気づいたよって場合に以下の手順で解決してください。（コミットしちゃった場合はまた別の方法で解決しましょう）

変更内容を退避させる

```
git stash
```

ブランチを切り替える

```
# ブランチを新しく作る場合
git checkout -b new_branch_name
```

```
# すでにあるブランチ使用する場合
git checkout branch_name
```

退避した変更を確認する

```
git stash list
```

出力結果（例）

```
stash@{0}: WIP on sub: a0d2f1b add fourth line
stash@{1}: WIP on sub: 1a61919 add second line
```


復活させたい変更内容を指定し、復活させる

```
git stash apply stash@{0}
```",2018-11-07 04:43:41 UTC,2018-11-07 04:43:41 UTC
12,Ruby,入出力を行うためのメソッド一覧,"# 入出力を行うためのメソッド一覧
Rubyには、ターミナルに様々なデータを表示するためのメソッドがいくつか用意されています。

- puts
- p
- print

特に、 `puts` と `p` に関しては、ログの表示、テスト、デバッグなど、様々な場面で利用されます。

基本的、かつ、非常に汎用性の高いメソッドなので、ぜひ使えるようにしてみてください。

# puts
`puts` は、データを出力する際に、最後に改行が入ります。

ターミナルに値を出力する際には、この `puts` が非常によく使われるので、ここで使い方を理解しておきましょう。

## 文字の表示
putsの基本的な使い方は以下の通りです。

```ruby
puts ""Hello World!!""
```

以上のように書くと、ターミナルに `Hello World!!` という文字列が表示されます。ここで注意しなければいけないのは、文字列を表示するときは `""""（ダブルクウォーテーション）` で囲むということです。これがないと文字列として認識してもらえずエラーになるので注意してください。

それでは実際に、 `puts` を使って `Hello World!!` を表示してみましょう。そのためにまずは、Rubyのファイルを作成します。テキストエディタを立ち上げ、 `command + s` で保存しましょう。

上書き保存（最初の一回は名前をつけて保存）

```
command + s
```

ファイル名は `hello.rb` にしてください。その時に使用する `.rb` は `拡張子` と呼ばれるものです。

これにより、どういう種類のファイルなのかをコンピュータに認識させることができます。

拡張子には、 `.rb` の他にも `Word` ファイルを表す `.docx` や `PDF` ファイルを表す `.pdf` などいろんな種類があります。

今回は、Rubyのファイルなので拡張子に `.rb` とつけて保存します。保存先はデスクトップにしてください。

```
hello.rb
```

ファイルが保存できたら、 `hello.rb` に以下のコードを書きましょう。

`puts` のコードを入力する際には、 `""Hello World!!""` との間に半角スペースを入れてください。

```ruby
puts ""Hello World!!""
```

そして、コードを書いたら必ず `command + s` で上書き保存する癖をつけてください。本当によく使う機能なので、このショートカットキーは覚えておくとかなり楽です。

ではさっそく、`hello.rb`の中に記述したコードをターミナルから実行してみましょう。まずは、`cd`コマンドを使用して、ターミナルでデスクトップに移動します。

```
cd desktop
```

このように、Rubyのコードを実行する場合は、コードを書いたファイルがある場所まで移動します。

もし、今回作成した `hello.rb` を `ruby_sample` というフォルダ（ディレクトリ）に保存した場合は `cd ruby_sample` というコマンドをターミナルに入力して移動します。

ちなみに、 `cd` は `change directory` という意味になります。

`cd` コマンドで移動ができたら、以下のコマンドを入力してコードを実行してください。

```
ruby hello.rb
```

実行結果

```
Hello World!!
```

今回出力した `Hello World` は、「文字列」と呼ばれるものです。

プログラミングでは、文字のことを文字列、数字のことを整数や少数などという風に区別します。

例えば、 `""1""` は文字列 `1` は整数となり、全く別のデータとして扱われることに注意してください。

`1 + 2` は答えが `3` として計算できますが、 `""1 + 2""` はただの文字列なので計算できません。

また、文字列の場合は `'（シングルクウォーテーション）` または `""（ダブルクウォーテーション）` で値を囲む必要があります。

基本的にはダブルクウォーテーションが多いのですが、2種類の表現方法があることを頭に入れておいてください。

それでは、以下のコードを `hello.rb` に記述してください。

```ruby
puts 'Single Hello World'
puts ""Double Hello World""
```

ターミナルで以下のコマンドを入力し、プログラムを実行しましょう。

```
ruby hello.rb
```

そうすると以下のような表示になります。シングルクウォーテーションもダブルクウォーテーションも、どちらも表示には違いがないことを確認しましょう。

```
Single Hello World
Double Hello World
```

また、コード内にはメモが書けるということもここで理解しておきましょう。

以下のように `#` を使用してメモを追加してみてください。

```ruby
# 文字を出力するコード
puts 'Single Hello World'
puts ""Double Hello World""
```

ターミナルで以下のコマンドを入力し、プログラムを実行しましょう。

```
ruby hello.rb
```

そうすると以下のような表示になります。

```
Single Hello World
Double Hello World
```

このように、 `#` の後にコメントを書いても実行結果には影響を与え無いことを理解しておきましょう。

なので、自分自身が気づいたことや説明などは、 `#` の後にメモとして記述してください。そうすると、復習するときにとても役に立ちます。

```ruby
# 文字を出力するコード
# シングルクウォーテーションでの記述
puts 'Single Hello World'
# ダブルクウォーテーションでの記述
puts ""Double Hello World""
```

## 数字の表示
`puts` を使って数字を表示するときは以下のように書きます。

```ruby
puts 3
```

文字列のように `""""` を書く必要はありません。

それでは、 `number.rb` をデスクトップに作成し、以下のコードを書いて実行してみましょう。

コードを実行する際は、 `cd` コマンドを使用してファイルのある場所まで移動することを忘れず行ってください。

今回も、 `number.rb` をデスクトップに作成したので、ターミナルでも以下のコマンドを実行してデスクトップに移動します。（すでにデスクトップに移動できている場合は実行しなくて大丈夫です）

```
cd desktop
```

 `number.rb` に、以下のコードを書いてください。

```ruby
puts 1
```

実行結果

```
1
```

以上のように、整数を表示するときは `""""` で囲む必要がないことを理解しておきましょう。

また、計算式を書くと自動で値を計算し、その結果を出力してくれます。

```ruby
# 数字の場合
puts 1 + 3
# 文字列の場合
puts ""1 + 3""
```

実行結果

```
4
1 + 3
```

このように、Rubyでは計算結果を `puts` で出力することもできます。また、`""""` で囲んだ場合は数字ではなく文字列として認識されるので、計算はできないことに注意しましょう。

今回は足し算を例に出しましたが、Rubyに用意されている計算方法はそれだけではなく、引き算、掛け算、割り算などの計算も行えます。良い機会なので、Rubyでの四則演算についてもついでに理解しておきましょう。

また、この計算方法についてはだいたいどの言語でも同じなので、頭に入れておくと他の言語にも幅広く応用できます。

## 四則演算
Rubyでの四則演算には以下の種類があり、計算する時に使用される記号は`演算子`と呼ばれます。

|演算子|内容|例|
|---|---|---|
|+|足し算（加算）|2 + 2|
|-|引き算（減算）|3 - 3|
|*|かけ算（乗算）|4 * 4|
|/|割り算（除算）|5 / 5|

ではさっそく`puts`を利用し、四則演算の計算結果を表示してみましょう。

```ruby
puts 2 + 2
puts 3 - 3
puts 4 * 4
puts 5 / 5
```

実行結果

```
4
0
16
1
```

もちろん、演算子は複数続けて記述することもできます。

```ruby
puts 2 + 2 + 2
```

ただし、文字と数字を続けて表示する場合、以下のように書くとエラーになります。

```ruby
puts ""2 + 2 = "" + 4
```

実行結果

```
TypeError: no implicit conversion of Fixnum into String
```

その理由は、「文字」と「数字」という種類の異なるデータで足し算しようとしたためです。

これだと、正常な処理ができません。

もし、上記のやり方でエラーを回避したい場合は、`to_s`メソッドを使用して数字を文字に変換してあげます。

```ruby
puts ""2 + 2 = "" + 4.to_s
```

実行結果

```
2 + 2 = 4
```

このように、「文字」と「数字」という種類の異なるデータを表示する場合は特別な変換をする必要があることを理解しておいてください。

そして、変換が必要かどうかを判断できるようなるためにはオブジェクトの種類を理解しておく必要があります。

#＃ Rubyのオブジェクト
Rubyには、以下のような種類のオブジェクトが存在ます。

一度に全て覚える必要はないですし、使っていくうちにだんだん覚えるものなので、最初は「こういうものがあるんだな」くらいの認識で大丈夫です。

さらっと確認してみてください。

|種類|オブジェクト名|
|---|---|
|整数|Fixnum|
|小数|Float|
|文字列|String|
|配列|Array|
|連想配列|Hash|
|true|TrueClass|
|false|FalseClass|
|nil(存在なし)|NilClass|


それぞれのオブジェクトは、実際には以下のように記述されます。

```ruby
# 整数:Fixnum
1
# 小数:Float
1.0
# 文字列:String
""文字列""
# 配列:Array
[1, 2, 3]
# 連想配列:Hash
{""key"" => ""value""}
# true:TrueClass
true
# false:FalseClass
false
# nil（存在なし:NilClass
nil
```

Rubyでは以上のようなオブジェクトの種類を意識する必要がありますが、今は「文字列」と「数字」だけ把握しておきましょう。

# p
`puts`の場合は出力されたデータがどのデータ型かわかりませんでした。しかし、`p`メソッドを利用すると、データ型の種類を確認することができます。

```ruby
p ""こんにちは""
p 1
```

実行結果

```
""こんにちは""
1
```

`puts`と`p`を比較してみると、`p`を利用するメリットがわかりやすいかと思います。

```
puts ""1""
p ""1""
```

実行結果

```
1
""1""
```

以上のように、`puts`で出力すると`1`という値が文字列なのか数字なのか判断できないのですが、`p`で出力するとそれが文字列だとわかります。このように、プログラムの中で使用されているデータがどのデータ型なのかを把握したい場合、`p`がとても役に立ちます。

# print
`print`は、改行を行わずに処理結果を表示するメソッドです。そこまで使用頻度は高くないので、特に意識して覚える必要はありません。`print`に関しては、`puts`と比較すると違いがわかりやすいので以下のコードを書いてみましょう。

```ruby
puts ""私の""
puts ""名前は""
puts ""神里です。""
puts ""-----------""
print ""私の""
print ""名前は""
print ""神里です。""
```

# 複数のデータを出力
`puts` `p` `print`に関しては、複数の値を出力させることも可能です。

```ruby
puts ""お"", ""は"", ""よ"", ""う""
p ""お"", ""は"", ""よ"", ""う""
print ""お"", ""は"", ""よ"", ""う""
```

実行結果

```
お
は
よ
う
""お""
""は""
""よ""
""う""
おはよう
```

# ヒアドキュメント
複数行の文字を出力したい場合、もちろん`puts`でも可能なのですが、ヒアドキュメントを使用するともっと楽になります。ヒアドキュメントの基本的な書き方は以下の通り。

```ruby
puts <<~TEXT
私の
名前は
神里です
TEXT
```

実行結果

```
私の
名前は
神里です
```

`puts`と比べると、ヒアドキュメントの方がはるかに楽なのがわかるかと思います。

```ruby
# putsを使用した場合
puts ""おはよう""
puts ""こんにちは""
puts ""こんばんは""

# ヒアドキュメントを使用した場合
puts <<~TEXT
おはよう
こんにちは
こんばんは
TEXT
```

実行結果

```
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
```

ちなみに、ヒアドキュメントを使用する際に文字列を`TEXT`で囲んでいるのですが、こちらは同じワードを使用して入れば記号以外ならなんでも大丈夫です。

```ruby
puts <<~TEXT
おはよう
こんにちは
こんばんは
TEXT

puts <<~亜亜亜
おはよう
こんにちは
こんばんは
亜亜亜

puts <<~あああ
おはよう
こんにちは
こんばんは
あああ

puts <<~aaa
おはよう
こんにちは
こんばんは
aaa

puts <<~111
おはよう
こんにちは
こんばんは
111
```

実行結果

```
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
```

途中の改行も、ちゃんと反映されます。これを`puts`でやるとかなりめんどくさい。

```ruby
# putsを使用した場合（空文字で改行）
puts ""おはよう""
puts """"
puts ""こんにちは""
puts ""こんばんは""

# ヒアドキュメントを使用した場合（Enterで改行）
puts <<~TEXT
おはよう

こんにちは
こんばんは
TEXT
```

実行結果

```
おはよう

こんにちは
こんばんは
おはよう

こんにちは
こんばんは
```

以上のように、ヒアドキュメントを利用すると`puts`を連打するより複数行のデータ出力がかなり楽になります。

# まとめ
今回は、入出力に関して以下のメソッドについて学びました。

- puts
- p
- print

これらのメソッドは、現場でもいろんな場面で利用されます。うまく使いこなせれば開発が楽になるので、ぜひ使ってみてください。",2018-11-07 04:48:23 UTC,2018-11-07 04:48:23 UTC
13,Ruby,変数,"# 変数
変数とは、値を入れておく箱のようなものです。この変数を使用すると、以下のようなメリットがあります。

- 値を使いまわせる
- 値を覚える必要がなくなる
- 変更に強いプログラムが組める

プログラムを組む上で、変数はかなり使用しますのでしっかりと理解しておきましょう。といっても、コードを書いていくうちに理解できるものなので、そこまで身構える必要はありません。

# 定義と代入
変数は、以下のように定義します。

```ruby
# name が変数
# ""satou"" が変数に格納する値
name = ""satou""
```

上のコードのように、`name`という入れ物を用意することで、`satou`という文字列が変数に格納されます。また、`name`の部分は自分の好きなように名前をつけてあげて大丈夫です。例えば、以下のようにいろんな変数を定義することができます。

```ruby
name = ""satou""
item = ""book""
price = 10000
```

# 式展開
変数の値を文字列の中で表示したい場合、以下のように記述します。

```ruby
name = ""Tanaka""

# 式展開を書くと表示される
puts ""Hello!! #{name}""

# そのまま変数名を書くと変数の値は表示されない
puts ""Hello!! name""
```

実行結果

```
Hello!! Tanaka
Hello!! name
```

また、式展開はヒアドキュメントの中で使用することもできます。

```ruby

name = ""Tanaka""

# ヒアドキュメントの中で式展開
puts <<~TEXT
Hello!! #{name}

You are very cool!!
Let's enjoy programming together!!
TEXT
```

# サンプルプログラム
では、変数を利用して、人の名前、年齢、住所、電話番号などの個人情報を表示するプログラムを書いてみましょう。

まずはファイルを作成します。テキストエディタを開いて「名前をつけて保存」を選択し、ファイル名を以下のようにして保存しましょう。`variable`は、「変数」という意味です。

```
variable.rb
```

ファイルが作成できたら、`variable.rb`にどんどんコードを追加していきます。

その際、随時`command + s(windowsは ctrl + s)`で上書き保存してから実行するようにしましょう。

記述したコードを実行するときは、以下のコマンドをターミナルから入力します。コー
ドが書けたら、このコマンドを実行して動作確認を行いましょう。

```
ruby variable.rb
```

それではさっそく、コードを書いていきます。

まずはそれぞれの変数を定義し、値を格納するところから。その際、どういうデータを格納する変数かがわかりやすいような変数名をつけてあげると、コードがグッと読みやすくなります。

```ruby
# 名前情報を入れる変数
name = ""Satou""
# 年齢情報を入れる変数
age = 33
# 住所情報を入れる変数
address = ""Tokyo""
# 電話番号を入れる変数
tell = ""080-2343-9183""
```

次に、それらの変数に格納した値を、式展開を用いてわかりやすい文章で表示してみましょう。

```ruby
# 名前情報を入れる変数
name = ""Satou""
# 年齢情報を入れる変数
age = 33
# 住所情報を入れる変数
address = ""Tokyo""
# 電話番号を入れる変数
tell = ""080-2343-9183""

# 変数に格納したデータを式展開で表示
puts ""【自己紹介】""
puts ""私の名前は#{name}です。""
puts ""年齢は#{age}です。""
puts ""今住んでいるところは#{address}です。""
puts ""電話番号は#{tell}です。""
puts ""宜しくお願いいたします！""
```

式展開で変数に格納したデータを表示することができたら、次はそれらのコードをヒアドキュメントに置き換えてリファクタリングしていきます。

ちなみに、リファクタリングとは、実行結果を変えずにコードを改善することです。これにより、コードの見通しや処理の効率が向上します。

```ruby
# 名前情報を入れる変数
name = ""Satou""
# 年齢情報を入れる変数
age = 33
# 住所情報を入れる変数
address = ""Tokyo""
# 電話番号を入れる変数
tell = ""080-2343-9183""

# ヒアドキュメントを使って式展開
puts <<~TEXT
【自己紹介】
私の名前は#{name}です。
年齢は#{age}です。
今住んでいるところは#{address}です。
電話番号は#{tell}です。
宜しくお願いいたします！
TEXT
```

# まとめ
変数はプログラミングの中でも使用する頻度がかなり高いです。これを使用することにより、コードの見通しが良くなったり、変更に強いプログラムを組むことができるようになります。

ぜひ、コードを書くときも、変数に置き換えられる箇所はないかを考えてみてください。",2018-11-07 04:48:50 UTC,2018-11-07 04:48:50 UTC
14,Ruby,条件分岐,"# 条件分岐
条件分岐とは、「もし〜だったら〜の処理をする」というように、条件によって行う処理を変えるために使用されるものです。条件分岐を実装するときには`if`や`unless`を使用します。ではさっそく、それぞれの使い方を学んでいきましょう。

## if
`if`の基本的な書き方は以下の通りとなります。

```ruby
hp = 10

if hp >= 10
  puts ""勇者のHPは10以上だ""
end
```

`if`の右側に書かれている`hp >= 10`が条件式となります。こちらの評価結果が成り立つ場合に、`if`と`end`で囲まれた部分の処理が実行されます。条件式にかかれている`>=`の部分は比較演算子と呼ばれ、以下のような種類があることを理解しておきましょう。

|比較演算子|意味|
|---|---|
|a >= b|aはb以上|
|a > b|aはb以下|
|a > b|aはbより大きい|
|a < b|aはbより小さい|
|a == b|aはbと等しい|

比較演算子の中でも`a == b`の部分を`a = b`という風に`=`を1つ書き忘れることがよくあるので気をつけてください。それだと「代入」という意味になってしまいます。また、比較演算子は実行されると`true`か`false`が結果として返ってくることを理解しておきましょう。

それでは、以下の名前のファイル名を作成しましょう。

```
if_sample.rb
```

`if_sample.rb`が作成できたら、次のコードを書いてください。

```ruby
a = 10
b = 15

print ""aはb以上？：""
puts a >= b
print ""aはb以下？：""
puts a <= b
print ""aはbより大きい？：""
puts a > b
print ""aはbより小さい？：""
puts a < b
print ""aはbと同じ？：""
puts a == b
```

コードが記述できたら、以下のコマンドをターミナルから実行し、結果を確認してみましょう。

```
ruby if_sample.rb
```

実行結果

```
aはb以上？：false
aはb以下？：true
aはbより大きい？：false
aはbより小さい？：true
aはbと同じ？：false
```

`if`は比較演算子の評価結果が`true`になるか`false`になるかを判断し、行う処理を決めています。

そのため、以下のように記述してもエラーは表示されず、きちんと処理が実行されます。

```ruby
# 条件がtrueの場合は実行される
if true
  puts ""実行されます""
end

# 条件がfalseの場合は実行されない
if false
  puts ""実行されません""
end
```

実行結果

```
実行されます
```

このように、`if`の条件式に使用されている比較演算子では、評価結果として`true`か`false`かの判定が行われていることを理解しておいてください。

## else
`if`の部分に書いた条件式の評価結果が`false`のときに行いたい処理がある場合は`else`を使用します。

```ruby
hp = 5

if hp >= 10
  puts ""勇者のHPは10以上だ""
else
  # ifの条件が成り立たない場合の処理
  puts ""勇者のHPは10より下だ""
end
```

`else`を使用することによって、わざわざもう１つ`if`文を書かなくてもよくなり、コードがスマートになります。

以下が、ちょっとイマイチな例です。

```ruby
hp = 5

if hp >= 10
  puts ""勇者のHPは10以上だ""
end

if hp < 10
  puts ""勇者のHPは10より下だ""
end
```

`if`をわざわざ２つ書いているので、表現が冗長ですね。このような場合は、`else`を使った方がスッキリします。

## elsif
`elsif`は`if`の部分に加え、さらに条件を追加したいときに使用します。

`elseif`ではなく、`elsif`だということに注意してくださいね！

```ruby
hp = 3

if hp > 10
  puts ""勇者は元気だ""
# 複数の条件を指定するときに使う
elsif hp > 5
  puts ""勇者は弱っている""
elsif hp > 3
  puts ""勇者はかなり弱っている""
elsif hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

この`elsif`も、複数条件で処理を行いたいときに、冗長な表現を避けることができます。

ちなみに、`elsif`を使わないとこんな感じになります。

```ruby
hp = 3

if hp > 10
  puts ""勇者はピンピンしている""
end

if hp > 10
  puts ""勇者は元気だ""
end

if hp > 5
  puts ""勇者は弱っている""
end

if hp > 3
  puts ""勇者はかなり弱っている""
end

if hp > 0
  puts ""勇者は瀕死だ""
end

if hp <= 0
  puts ""勇者はしんだ""
end
```

うん、超めんどくさい！笑

ちなみに、条件がたくさんあり、かつ、「〜と〜が等しい」みたいな条件を判定する場合は、`case`を使うこともあります。

|文法|特徴|
|---|---|
|if|~以上、~以下と行った判定ができる|
|case|1つの比較対象に対して複数の条件分岐を行う|

以下が、`case`の使用例です。

```ruby
month = 6

# 比較対象をcaseの後に記述
case month
# 比較対象と比較する値を記述
when 3, 4, 5
  puts ""春です""
when 6, 7, 8
  puts ""夏です""
when 9, 10, 11
  puts ""秋です""
when 12, 1, 2
  puts ""冬です""
else
　puts ""不正な値です""
end
```

ちなみに、この`case`に対しても、条件判定の部分で範囲オブジェクト（`3..5`など）を使用できます。

```ruby
month = 6

# 比較対象をcaseの後に記述
case month
# 比較対象と比較する値を記述
when 3..5
  puts ""春です""
when 6..8
  puts ""夏です""
when 9..11
  puts ""秋です""
when 12..2
  puts ""冬です""
else
　puts ""不正な値です""
end
```

実行結果

```
夏です
```

# ifの省略形
実は、`if`は1行で書くこともできます。条件を１つしか判定しない場合はこのほうがスッキリするので、意識して使うようにして見てください。実際に現場でもこの使い方はよく見ます。

```ruby
# 省略形
puts ""勇者のHPは10以上だ"" if hp >= 10
```

## 三項演算子
見慣れていない方はちょっと混乱されるかもしれませんが、条件分岐には`三項演算子`というものも存在します。ちょっと書き方は複雑ですが、こちらも現場ではよく用いられるものなので、使えるように意識してみてください。

```ruby
hp = 11

# 条件式(true or false) ? trueの時に行いたい処理 : falseの時に行いたい処理
puts hp > 10 ? ""勇者のHPは10より大きいです"" : ""勇者のHPは10より小さいです""
```

# サンプルプログラム
それでは、`if`を利用したサンプルプログラムを作っていきましょう！

まずは、以下のような名前のファイルを作成し、保存します。

```
conditional.rb
```

それでは、`conditional.rb`にコードを書いていきましょう。今回は、`if`を使用して戦闘ゲームを再現していきます。

まずは、それぞれのキャラクターのパラメータを変数に入れましょう！慣れない人は、`#`でコメントも書いておくと、後から見返したときに理解しやすいです。

```ruby
# 勇者のhp
brave_hp = 30
# 勇者の攻撃力
brave_attack = 10
# 勇者の防御力
brave_defense = 5
# 敵のhp
enemy_hp = 30
# 敵の攻撃力
enemy_attack = 5
# 敵の防御力
enemy_defense = 10
```

それでは次に、キャラクターが攻撃をするときの処理を書いていきましょう。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

# 敵に与えるダメージの計算
enemy_damage = brave_attack - enemy_defense
```

敵に与えるダメージの計算ができたら、それを敵のHPから引き算してダメージを与える処理を書きます。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
# 敵のHPにダメージを与える
enemy_hp = enemy_hp - enemy_damage
```

敵にダメージを与えるコードが追加できたら、`if`を利用して、残りHPによって敵キャラのリアクションを変えるようにしましょう！

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
enemy_hp = enemy_hp - enemy_damage

# 敵に与えるダメージと残りHPの表示
puts ""敵に#{enemy_damage}のダメージを与えた。""
puts ""残りHPは#{enemy_hp}だ。""

# 残りHPによってリアクションを変える
if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end
```

それでは同様に、敵から勇者へ攻撃を行うときの処理も追加していきましょう！できるひとは、サンプルコードを見ずに自分で考えてコードを書いて見てください。自分で考えてコードを書くと、かなり勉強になりますよ。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
enemy_hp = enemy_hp - enemy_damage

puts ""敵に#{enemy_damage}のダメージを与えた。""
puts ""残りHPは#{enemy_hp}だ。""

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end


# 敵に与えるダメージの計算
brave_damage = enemy_attack - brave_defense
# 敵のHPにダメージを与える
brave_hp = brave_hp - brave_damage

# 敵に与えるダメージと残りHPの表示
puts ""敵から#{brave_damage}のダメージを受けた。""
puts ""残りHPは#{brave_hp}だ。""

# 残りHPによってリアクションを変える
if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者は死んだ""
end
```

コードを書いたら、プログラムを実行して動作確認してみましょう。
エラーが表示されていなければ完成です。

以上で簡単なゲームの再現はできました。
しかし、こちらのコードにはまだまだ改善の余地があります。

では、これからサンプルコードを改善（リファクタリング）していきましょう。

まずは、ヒアドキュメントを使用し、`puts`を使用している部分をもう少しスッキリ記述できるようにします。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
enemy_hp = enemy_hp - enemy_damage

# ヒアドキュメント
puts <<~TEXT
敵に#{enemy_damage}のダメージを与えた。
残りHPは#{enemy_hp}だ。
TEXT

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵は死んだ""
end

brave_damage = enemy_attack - brave_defense
brave_hp = brave_hp - brave_damage

# 敵に与えるダメージと残りHPの表示
puts <<~TEXT
敵から#{brave_damage}のダメージを受けた。
残りHPは#{brave_hp}だ。
TEXT

# 残りHPによってリアクションを変える
if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

これで、表示の部分はスッキリさせることができました。

他に、もう１つ改善点としてあげられるのは、攻撃の処理において決まった値しか計算されないことです。
これではゲーム性がないので、次に、与えるダメージがある一定の範囲で変化するような処理を書いて見ましょう。

この処理を実装するときには`rand`というメソッドを使います。

この`rand`は、数字を指定するとその中からランダムな値を表示してくれます。これを利用して、攻撃の処理をするさいのダメージを変化するように実装して見ましょう。

その際、`3..5`といった`範囲オブジェクト（Range）`というものを使用して`rand`を記述すると、指定した範囲の中でランダムな値を表示してくれるようになります。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

# 攻撃にランダム要素を入れる
# 範囲オブジェクト　3..5
enemy_damage = brave_attack - enemy_defense + rand(3..5)
enemy_hp = enemy_hp - enemy_damage

puts <<~TEXT
敵に#{enemy_damage}のダメージを与えた。
残りHPは#{enemy_hp}だ。
TEXT

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end

# 攻撃にランダム要素を入れる
# 範囲オブジェクト　3..5
brave_damage = enemy_attack - brave_defense + rand(3..5)
brave_hp = brave_hp - brave_damage

puts <<~TEXT
敵から#{brave_damage}のダメージを受けた。
残りHPは#{brave_hp}だ。
TEXT

if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

また、`rand`を使用すれば通常攻撃とクリティカルヒットをランダムに発生させることもできます。その際、`rand(4)`とかくと`0~3`のうちでランダムな数字を発生させることができます（1~4ではないことに注意してください）

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

# 攻撃にランダム要素を入れる
# rand(4)にすると0~3のうちランダムに数字を発生させる
select_attack = rand(4)

if select_attack == 0
  puts ""かいしんのいちげき""
  # randの範囲を20~30と大きな値にする
  enemy_damage = brave_attack - enemy_defense + rand(20..30)
  enemy_hp = enemy_hp - enemy_damage
else
  puts ""つうじょうこうげき""
  enemy_damage = brave_attack - enemy_defense + rand(3..5)
  enemy_hp = enemy_hp - enemy_damage
end

puts <<~TEXT
敵に#{enemy_damage}のダメージを与えた。
残りHPは#{enemy_hp}だ。
TEXT

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end

# 攻撃にランダム要素を入れる
# rand(4)にすると0~3のうちランダムに数字を発生させる
select_attack = rand(4)

if select_attack == 0
  puts ""かいしんのいちげき""
  # randの範囲を20~30と大きな値にする
  brave_damage = enemy_attack - brave_defense + rand(10..20)
  brave_hp = brave_hp - brave_damage
else
  puts ""つうじょうこうげき""
  brave_damage = enemy_attack - brave_defense + rand(3..5)
  brave_hp = brave_hp - brave_damage
end

puts <<~TEXT
敵から#{brave_damage}のダメージを受けた。
残りHPは#{brave_hp}だ。
TEXT

if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

これでだいぶリファクタリングができました。他にも自分なりに工夫できる部分はあるかと思いますので、ぜひこちらのコードをカスタマイズしてオリジナルプログラムを組んでみてください。

# まとめ
`if`が使えるようになると、行える処理もかなり柔軟になります。現場でもよく使用するので、`if`を使って無駄なく柔軟にプログラムを書く練習をなんどもやってみてください。

お疲れ様でした！",2018-11-07 04:49:15 UTC,2018-11-14 07:59:41 UTC
15,Ruby,メソッド,"# メソッド
メソッドとは一言で言うと「処理のかたまり」です。

例えば、「選んだ商品と購入する数によって合計金額を計算する」とか「入力したIDとパスワードを判定してログインできるかどうかを判定する」などの一連の処理をまとめ、プログラムの中でいつでもどこでも簡単に必要な処理を呼び出せるようにしたものです。

とはいっても、実際にメソッドを利用してみないとイメージがわかないので、さっそくメソッドを定義してみましょう。

# メソッドの定義と使い方
メソッドの定義は以下のようになります。

```ruby
def メソッド名

end
```

「メソッド名」の部分には、任意の名前をつけてあげます。

大体の場合は、「どう言う処理を行うメソッドか？」と言うことがわかりやすいように、動詞で名前をつけてあげます。

それでは、「選んだ商品と購入する数によって合計金額を計算するメソッド」を定義していきましょう。

まず、メソッド名は以下のようにします。

```ruby
# 合計金額を表示するメソッド
def disp_sum

end
```

以上で `disp_sum` という名前のメソッドが定義できました。

それでは、 `disp_sum` の中に具体的な処理を書いていきましょう。

```ruby
def disp_sum

  # 商品の値段(price)と個数(num)
  price = 1980
  num = 20

  # 商品の合計購入金額を計算
  price * num

end
```

メソッドの定義が終わったら、さっそくメソッドを呼び出してみましょう。

呼び出す際は以下のように記述します。

```ruby
def disp_sum

  price = 1980
  num = 20

  price * num

end

puts disp_sum
```

実行結果

```
39600
```

これではちょっと味気ないので、式展開を使って意味がわかりやすいような表示にしてみましょう。

```ruby
def disp_sum

  price = 1980
  num = 20

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
```

Rubyにおいて、メソッドは最後に評価した値を呼び出し元に戻します。

先ほどのコードにおいて呼び出し元とは `puts disp_sum` の部分です。

この部分に、メソッドの最後に実行された `price * num` の値が返ってきます。

そのため、 `price * num` の計算結果である `39600` という値が返ってきたわけです。

ちなみに、以下のようにメソッドの中に `return` を加えても同じように処理ができます。


```ruby
def disp_sum

  price = 1980
  num = 20

  # return を記述
  return ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
```

このようにメソッドの中では `return` を記述しても `price * num` の実行結果を呼び出し元である `puts disp_sum` の部分に返すことができます。

また、他の言語でも同様にメソッドの中では戻り値を返すためによく `return` を使用します。

しかし、Rubyのメソッドでは、先ほども説明したように最後に評価した値を呼び出し元に返してくれます。

そのため、ほとんどの場合メソッドの中には `return` を記述しません。

`return` を使うのは、メソッドの途中で処理を抜けたいときです。

例えば、以下の場合をみてみましょう。

```ruby
def disp_sum

  price = 1980
  num = -1

  # return を記述
  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

実行結果

```
商品の購入数は0以上にしてください
```

このように、メソッドの途中で処理を抜けたい場合に `if` などの条件分岐と合わせて使用することがよくあります。

この使い方を覚えておくと、現場でも役に立つことがありますよ。

# メソッドの引数
メソッドには「引数」という処理の材料を渡すことができます。

この引数を使用することにより、より柔軟な処理ができるようになります。

では、以下のコードを例に説明していきましょう。

```ruby
def disp_sum

  price = 1980
  num = 20

  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

上のコードでは、何度実行しても `price` の値は `1980` で、 `num` の値は `20` の計算しかできません。これでは、全く柔軟性のないメソッドになってしまいますね。

しかし、このメソッドに引数を使えば、とても柔軟に値の計算ができるようになります。

それではさっそく、引数を使ったメソッドを定義していきましょう。

```ruby
# ()の中のprice, numが引数を受け取る変数
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# ()の中の値がdisp_sumの引数：左からprice, numの順番となる
puts disp_sum(1980, 20)
puts disp_sum(2480, 20)
puts disp_sum(72980, 20)
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
2480円の商品を20個買ったので、合計金額は49600です
72980円の商品を20個買ったので、合計金額は1459600です
```

これでかなり柔軟に計算ができるようになりましたね。

`disp_sum(1980, 20)` や `puts disp_sum(2480, 20)` のように、引数に渡してあげる値を変えれば、それに応じて柔軟に計算結果を変えることができます。

また、試しに `num` の部分に入る数を `-1` にしてみましょう。

```ruby
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# 引数を-1にする
puts disp_sum(1980, -1)
```

実行結果

```
商品の購入数は0以上にしてください
```

`num` の引数を `-1` にすると、きちんと注意文が表示されました。

この注意文に関しても、入力した値が表示されるようにちょっと改善しましょう。

```ruby
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください：入力値 #{num}"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# 引数を-1にする
puts disp_sum(1980, -1)
```

実行結果

```
商品の購入数は0以上にしてください：入力値 -1
```

このように、引数を使用するとだいぶ処理の柔軟性が出てきます。

# デフォルト値付きの引数
先ほど引数付きのメソッドを定義する方法を学びました。

しかし、メソッドに引数を設定した場合、呼び出し元で引数を渡してあげないとエラーが出ます。

```ruby
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください：入力値 #{num}"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# 引数を無しにしてメソッドを呼び出し
puts disp_sum()
```

実行結果

```
ArgumentError (wrong number of arguments (given 0, expected 2))
```

これだと、引数に渡すデータが存在しない場合にはプログラムが途中で止まってしまいます。

しかし、Rubyのメソッドにはこのようなエラーを防ぐための仕組みがあります。

それが、引数のデフォルト値の設定です。

引数にデフォルト値を設定すると、「引数が存在する場合は引数を元に処理を行い、引数がない場合はデフォルト値を使って処理を行う」といった処理が可能になります。

引数に対するデフォルト値は以下のように設定することができます。

```ruby
# 引数にデフォルト値を設定
def disp_sum(price = 1980, num = 20)

  return ""商品の購入数は0以上にしてください：入力値 #{num}"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end
# 引数を無しにしてメソッドを呼び出し
puts disp_sum()
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
```

このように、引数にデフォルト値を設定すると、呼び出し元で引数を渡さなかったとしてもエラーが表示されなくなります。

こちらも現場ではよく使う書き方なのでぜひ、使えるようにしておいてください。

---
【練習問題】
車の色、値段、乗車人数を引数で渡すと

カラー：〜
値段：〜
乗車人数：〜

と引数に渡した情報を表示してくれるようなメソッドを定義しましょう。

メソッド名、引数名は自分で考えてください。

また、可能であれば引数のデフォルト値も自分で考えて設定してみましょう。
---

もし問題が解けたら神里に提出してください。

色々とアドバイスいたします！

# まとめ
メソッドは、効率よく複雑な処理を実装するためによく利用されます。

このメソッドの中でいかに効率の良い処理をかけるかどうかがプログラマーの腕の見せ所です。

メソッドの定義や使い方をしっかりと覚え、かつ、ほかの文法とどうやって組み合わせるかを常に考える癖をつけてみてください。

そうすることで、シンプルで効率の良い処理を素早く実装できるプログラマーになることができます。",2018-11-07 04:49:44 UTC,2018-11-16 08:49:58 UTC
16,Ruby,配列,"# 配列
配列は、複数のデータを格納することができるクラスです。データベースからユーザーや商品のデータを取り出す際、この配列がよく利用されるので、配列の定義の仕方や繰り返し分を活用したデータの取り出し方をよく確認しておきましょう。

# 配列の定義
配列は以下のように定義します。

```ruby
users = [""Saitou"", ""Tanaka"", ""Suzuki"", ""Yamada""]
```

上のサンプルの場合、`users`という変数には`Saitou`, `Tanaka`, `Suzuki`, `Yamada`の4人の名前が格納されています。このように、複数のデータを一括で管理することができるので、配列を利用すると大量のデータを簡単に扱うことができるようになります。

また、配列は文字列だけでなく数字も格納することができます。

```ruby
ages = [22, 34, 12, 45]
```

# 配列から要素を取り出す
配列から要素を取り出すには、以下のように記述します。

```ruby
ages = [22, 34, 12, 45]

puts ages[0]
```

出力結果

```
22
```

上の例では、`ages[0]`の部分で配列の中の要素を取り出すことができます。その際使用する`0`という数字はインデックス番号を示しており、`配列の中の0番目の要素を指定する`という意味になります。では、0番目の要素とはどれを指すのでしょう？

実は、配列においては一番最初の要素が`0番目`というふうに決められています。つまり、今回のサンプルで使用した`ages`という配列だと、`22 => 0番目`、`34 => 1番目`、`12 => 2番目`、`45 => 3番目`となります。

```ruby
ages = [22, 34, 12, 45]

# 0番目の要素：22を取り出す
puts ages[0]

# 1番目の要素：34を取り出す
puts ages[1]

# 2番目の要素：12を取り出す
puts ages[2]

# 3番目の要素：45を取り出す
puts ages[3]
```

# 配列と繰り返し処理
配列は、繰り返し処理と組み合わせると処理の効率が格段に上がります。その際、配列との組み合わせでよく利用されるのが、[繰り返し処理](/ruby/loop.md)の部分で学んだ`each`です

```ruby
users = [""satou"", ""tanaka"", ""yamada"", ""shimizu""]

users.each do |name|
  puts ""Hello!! #{name}.""
end
```

実際に現場では、1万件以上のユーザーのデータをデータベースから取り出して表示することもあるので、配列と繰り返し処理を組み合わせて使用しないと大変なことになります。「配列から要素を取り出すときは繰り返し処理で取り出す」ということを頭に入れておきましょう。`ages[0]`のような取り出し方は、現場ではほとんど使用しません。",2018-11-07 04:50:16 UTC,2018-11-07 04:50:16 UTC
17,Ruby,繰り返し処理,"# 繰り返し処理
繰り返し処理は、何度も同じ処理を繰り返したい時に使用するものです。他の言語では`while`や`for`を使用すると思いますが、Rubyではこれらの文法はほとんど使用しません。（実際、現場で一度も見たことない）

というわけで、Ruby特有の繰り返し処理について勉強していきましょう。まずは`each`を知ることから！

# each
`each`は配列や範囲オブジェクトに対して使用することができる繰り返し処理です。ちなみに、配列とは何個も要素を格納することができるもので、範囲オブジェクトとは`0~100`のように、数値的な範囲を表すデータのことです。

それではさっそく、`each`の使い方を確認していきましょう。以下のようにコードを記述してください。

```ruby
# 配列 複数のデータを格納できる
users = [""satou"", ""tanaka"", ""yamada"", ""shimizu""]

# 配列に対してeach文で中身を表示
# usersの要素１つ１つをnameに代入してブロック内の処理を実行
users.each do |user|
  puts ""Hello!! #{user}.""
end
```

実行結果

```
Hello!! satou
Hello!! tanaka
Hello!! yamada
Hello!! shimizu
```

はじめて`each`を見る人なら混乱するかと思います。落ち着いて、1つ1つ確認しながら進めていきましょう。まず、`each`のこの部分から。

```ruby
users.each do |user|
  # 行いたい処理
end
```

上の中で`users`は複数の要素が入った配列になります。その配列に対して`each`を実行することによって、要素を1つ1つ取り出して処理を行うことができるわけです。で、そのときに大切になってくるのが配列から取り出された各要素が`||`の中に囲まれた`user`に代入されることです。

まとめると、配列の`users`に対して`each`を使用すると、1つ1つの要素が`user`に代入され、`do`と`end`で囲まれた部分の処理が実行されるということになります。

この`each`については、構文がわりと複雑なので理解がしにくいかと思いますが、いろんなサンプルを書いて実行し、`each`を書くことに慣れていきましょう。

```ruby
ages = [20, 60, 27, 23]

ages.each do |age|
  puts ""I'm #{age} years old.""
end
```

```ruby
items = [""book"", ""food"", ""movie"", ""music""]

items.each do |item|
  puts ""I bought #{item}""
end
```

```ruby
prefectures = [""Hokkaido"", ""Okinawa"", ""Saitama"", ""Ibaraki""]

prefectures.each do |prefecture|
  puts ""#{prefecture} is awesome!!""
end
```

# each.with_index
`each`と似た繰り返し処理として、`each.with_index`があります。これは、名前の通り繰り返し処理である`each`を`index`番号付きで実行するということになります。基本的な書き方は以下の通り。

```ruby
users = [""satou"", ""tanaka"", ""yamada"", ""shimizu""]

# インデックス番号と配列の要素を同時に出力
users.each.with_index do |name, i|
  puts ""No.#{i} #{name}""
end
```

実行結果

```
No.0 satou
No.1 tanaka
No.2 yamada
No.3 shimizu
```

実行結果のように、`each.with_index`を利用すると、番号付きで繰り返し処理を実行してくれます。今回のサンプルのように会員No.を表示したいときなどに非常に便利です。

では、コードの解説に移りましょう。

`each.with_index`では、配列の中身が`||`で囲んだ部分に代入されるのは、前項で学んだ`each`と同じです。異なる部分は、`||`の中の変数が２つになることです。この2番目の変数の中に、インデックス番号の情報が格納されます。

```ruby
# 変数iにインデックス番号の情報が入る（iでなくてもindexやnumなどでも良い）
users.each.with_index do |name, i|
  # iを利用してカウント
  puts ""No.#{i} #{name}""
end
```

ただ、実行結果をよく見ると一番最初の番号が0になっていますね。

```
No.0 satou
No.1 tanaka
No.2 yamada
No.3 shimizu
```

これはちょっと不自然なので、No.1からカウントを開始できるようにしてみましょう。

実は`each.with_index`は、インデックスの開始番号を指定できるようになっています。

```ruby
users = [""satou"", ""tanaka"", ""yamada"", ""shimizu""]

# インデックスの開始番号を指定
users.each.with_index(1) do |name, i|
  puts ""No.#{i} #{name}""
end
```

実行結果

```
No.1 satou
No.2 tanaka
No.3 yamada
No.4 shimizu
```

`each.with_index`は`each`と合わせて非常によく使われるので、ぜひ練習してみてください。

```ruby
ages = [20, 60, 27, 23]

ages.each.with_index(1) do |age, i|
  puts ""No.#{i} I'm #{age} years old.""
end
```

```ruby
items = [""book"", ""food"", ""movie"", ""music""]

items.each.with_index(1) do |item, i|
  puts ""No.#{i} I bought #{item}""
end
```

```ruby
prefectures = [""Hokkaido"", ""Okinawa"", ""Saitama"", ""Ibaraki""]

prefectures.each.with_index(1) do |prefecture, i|
  puts ""No.#{i} #{prefecture} is awesome!!""
end
```

# サンプルプログラム
では、これから繰り返し処理を使用してサンプルプログラムを作っていきましょう

今回は、「任意のメンバーを2つのチームに分ける」というプログラムをサンプルにコードを書いていきます。

まずはじめに、名前を格納するための配列を作成しましょう。

```ruby
# チーム分けするメンバーの名前を格納する配列を定義
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]
```

配列が作成できたら、その配列から要素を取り出すための`each`を書いていきます。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

# 配列を取り出すためのeach
user_list.each.with_index do |user, i|

end
```

`each`を書いたら、その中に各メンバーをチーム分けするための処理を書いていきます。

その際、`odd?`というメソッドを使用します。この`odd?`は整数オブジェクト（`Integer`）で使用できるメソッドで、整数が奇数だったら`true`を返し、そうじゃなかった場合は`false`を返します。そのため、`if`などの条件分岐を併せて利用されることが多いです。

ちなみに、`odd?`の他には`even?`もあります。`even?`は、整数オブジェクトが偶数なら`true`を返し、そうじゃなかった場合は`false`を返します。

|メソッド|処理|
|---|---|
|odd?|奇数ならtrue、偶数ならfalse|
|even?|偶数ならtrue、奇数ならfalse|

それでは、`odd?`を使用してチーム分けの処理を書いてみましょう。その際、チーム分けしたメンバーを格納するための配列を用意します。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

# チームA,Bのメンバーを格納するための配列
team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    # 配列に要素を格納する
    team_a << user
  else
    # 配列に要素を格納する
    team_b << user
  end
end
```

各チームの配列にメンバーを格納する処理ができたら、次はそのメンバーを表示するための処理を書きましょう。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

# チームAのメンバーを表示
puts ""チームA""
puts team_a
puts """"
# チームBのメンバーを表示
puts ""チームB""
puts team_b
```

これで一通り、チーム分けのプログラムは完了しました。

しかし、まだまだ改善の余地はあります。ここからどんどんリファクタリングしていきましょう。

まずは、チームメンバーの情報を変数に格納して一気に表示できるようにします。その際、`+=`を使用することで、変数の中に格納された文字列に対して、追加で文字列を足し合わせていきます。このような処理を`文字列連結`といいます。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

# チームAのメンバーを表示
text = ""チームA""
team_a.each do |member|
  # テキストに文字列連結
  text += member
end
# チームBのメンバーを表示
text += ""チームB""
team_b.each do |member|
  # テキストに文字列連結
  text += member
end

# チーム分けの情報を表示
puts text
```

これで`puts`を使用する回数を減らすことができたのですが、実行してみると表示がおかしなことになってしまいます。

実行結果

```
チームASaitouImaiTakahashiチームBYanagiAoyagiObata
```

これではかえって読みにくくなってしまうので、途中に改行を入れるようにしてみましょう。

Rubyの文字列の中で改行を行いたい場合は、改行コード`\n`を使用します。`n`の前にある`\（バックスラッシュ）`を入力したい場合は`option + ¥`を押しましょう。そうすると、`\`を入力することができます。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

# \nを入れて改行
text = ""チームA\n""
team_a.each do |member|
  text += ""#{member}\n""
end
text += ""\nチームB\n""
team_b.each do |member|
  text += ""#{member}\n""
end

puts text
```

これで、読みやすく表示することができるようになりました。

実行結果

```
チームA
Saitou
Imai
Takahashi


チームB
Yanagi
Aoyagi
Obata
```

ただ、各メンバーを表示するだけなら、あまり`each`を使用するメリットはありません。以下のように記述しても、スッキリと書くことができるからです。

```ruby
puts ""チームA""
puts team_a
puts """"
puts ""チームB""
puts team_b
```

ただ、各チームメンバーに対して文字列を付け加えたい場合は、`each`の方が便利です。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

text = ""チームA\n""
team_a.each do |member|
  # チームメンバーを「〜さん」と表示する
  text += ""#{member}さん\n""
end
text += ""\nチームB\n""
team_b.each do |member|
  # チームメンバーを「〜さん」と表示する
  text += ""#{member}さん\n""
end

puts text
```

実行結果

```
チームA
Saitouさん
Imaiさん
Takahashiさん

チームB
Yanagiさん
Aoyagiさん
Obataさん
```

さらに、各メンバーに番号を振るなら、以下のようにコードを書くことができます。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

text = ""チームA\n""
# each.with_indexに変更
team_a.each.with_index(1) do |member, i|
  # 各メンバーに番号を振る
  text += ""No.#{i}：#{member}さん\n""
end
text += ""\nチームB\n""
team_b.each.with_index(1) do |member, i|
  # 各メンバーに番号を振る
  text += ""No.#{i}：#{member}さん\n""
end

puts text
```

実行結果

```
チームA
No.1：Saitouさん
No.2：Imaiさん
No.3：Takahashiさん


チームB
No.1：Yanagiさん
No.2：Aoyagiさん
No.3：Obataさん
```

さて、最後に一番肝心なところをリファクタリングしていきましょう。

現在、メンバーのチーム分けは何回やっても同じ結果になってしまいます。これでは面白くないので、メンバーがランダムにチーム分けされるようにしましょう。

その際、配列オブジェクトには便利なメソッドが用意されています。それが、`shuffle`です。`shuffle`は、配列の各要素をランダムに並び替えるメソッドです。

以下のようにコードを追加してみましょう。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

# user_listの要素をランダムに入れ替える
user_list.shuffle

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

text = ""チームA\n""
# each.with_indexに変更
team_a.each.with_index(1) do |member, i|
  # 各メンバーに番号を振る
  text += ""No.#{i}：#{member}さん\n""
end
text += ""\nチームB\n""
team_b.each.with_index(1) do |member, i|
  # 各メンバーに番号を振る
  text += ""No.#{i}：#{member}さん\n""
end

puts text
```

これで配列の要素はランダムに入れ替えられる処理を書くことができました。しかし、実行結果を見てみましょう。

実行結果

```
チームA
No.1：Saitouさん
No.2：Imaiさん
No.3：Takahashiさん


チームB
No.1：Yanagiさん
No.2：Aoyagiさん
No.3：Obataさん
```

なんと、実行結果は`shuffle`を書く前と変わりません。これはなぜでしょう？

実は、`shuffle`を実行した時は確かに配列の各要素はランダムに入れ替えられているのですが、その場限りで処理が終わり、元のデータは書き換わってないのです。大切なのは、配列の要素を並び替え、その結果を元データに反映させること。つまり、`shuffle`の処理結果をきちんと`user_list`に反映させないといけないのです。

それを実現するためには、`shuffle`に`!`をつけます。そうすると、大元のデータである`user_list`もランダムにシャッフルされた後に元のデータが書き換えられるようになります。

ちなみに、このようなメソッドを`破壊的メソッド`と呼びます。

```ruby
user_list = [""Yanagi"", ""Saitou"", ""Aoyagi"", ""Imai"", ""Obata"", ""Takahashi""]

# user_listの要素をランダムに入れ替える
user_list.shuffle!

team_a = []
team_b = []

user_list.each.with_index do |user, i|
  if i.odd?
    team_a << user
  else
    team_b << user
  end
end

text = ""チームA\n""
# each.with_indexに変更
team_a.each.with_index(1) do |member, i|
  # 各メンバーに番号を振る
  text += ""No.#{i}：#{member}さん\n""
end
text += ""\nチームB\n""
team_b.each.with_index(1) do |member, i|
  # 各メンバーに番号を振る
  text += ""No.#{i}：#{member}さん\n""
end

puts text
```

実行結果

```
チームA
No.1：Obataさん
No.2：Imaiさん
No.3：Saitouさん


チームB
No.1：Aoyagiさん
No.2：Yanagiさん
No.3：Takahashiさん
```

これで、ランダムに各メンバーがチーム分けされるようになりました。

`shuffle!`のような破壊的なメソッドは、状況に応じて注意して使い分けてください。不用意に使用すると、エラーの原因になることもあります。

繰り返し処理に併せて様々なメソッドが出てきましたが、どれも便利なものばかりなので何度も繰り返し復習して定着させていきましょう。

# まとめ
Rubyでは、繰り返し処理には`each`をよく利用します。他の言語では、`for`や`while`がよく利用されており、実際に`Ruby`にも`for`や`while`はありますがほとんど使わないので特に勉強しなくて良いでしょう。

できるだけ、無駄を省きながら効率よく勉強されていくと、転職のスピードも早くなるかと思います。ぜひ、ショートカットしながら勉強を進めて行ってください。

お疲れ様でした！",2018-11-07 04:51:06 UTC,2018-11-07 04:51:06 UTC
18,Ruby,ハッシュ,"# ハッシュ
ハッシュは、配列と同様に複数のデータを扱うことができるクラスですが、データはキーとバリューの組み合わせになっています。

他の言語では、連想配列やディクショナリ、マップと呼ばれています。

Ruby on Railsにおいては新規登録、編集、削除機能を実装する際に、このハッシュが使用されています。

今後、Webアプリケーションを作成する上ではとても重要な役割を担うので、ぜひ使い方を理解しておいてください。

といっても、最初は値の代入と取り出し方がわかっていれば最初は大丈夫です。気構えずいきましょう。

```ruby
# 名前、メール、住所のデータが入ったハッシュの定義
# キー：name, email, address
# バリュー：Tanaka, hoge@co.ne.jp, Saitama
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }
# ハッシュからデータを取り出す
puts params[:name]
```

出力結果

```
Tanaka
```

ハッシュを使うメリットは、データの順番を意識しないで済むことです。

上のサンプルのように、 `name` を指定してデータを取り出すと、格納された順番に関係なく `name` に紐づく `Tanaka` というデータを取り出すことができます。

そのため「必要な処理をするためには〜番目のデータを取り出さなければいけない」といったように、順番を考慮する必要がありません。

また、ハッシュはキーとバリューの組み合わせでデータを扱うことができるので、名前やメールアドレス、住所など、色んな種類のデータを格納するときに便利です。

先ほどご紹介した他にも、ハッシュの定義方法としては以下のような書き方もあります。

```ruby
# キーがシンボルではなく文字列になっている
params = { ""name"" => ""Tanaka"", ""email"" => ""hoge@co.ne.jp"", ""address"" => ""Saitama"" }

puts params[""name""]
```

基本的には `name:` というようにシンボルを用いてキーを記述しますが、 `""name""` のように文字列でも記述できるということを頭に入れておきましょう。

また、ハッシュは以下のように途中で改行することもできます。現場でもよく利用される書き方なので、覚えておきましょう。

```ruby
# 途中で改行できる
params = {
            ""name"" => ""Tanaka"",
            ""email"" => ""hoge@co.ne.jp"",
            ""address"" => ""Saitama""
         }

puts params[""name""]
```

また、ハッシュの最後の要素の後にカンマがついてもエラーは出ません。

```ruby
params = {
            ""name"" => ""Tanaka"",
            ""email"" => ""hoge@co.ne.jp"",
            ""address"" => ""Saitama"", # カンマがあってもエラーは出ない
         }

puts params[""name""]
```

ハッシュで使用される `{}` の部分は、 `each` でも使用されるため、最初は混同しやすいかもしれません。

```ruby
# ハッシュ
{ ""name"" => ""Tanaka"", ""email"" => ""hoge@co.ne.jp"", ""address"" => ""Saitama"" }

# each {} を使用して以下のようにも書ける
[""satou"", ""tanaka"", ""yamada"", ""shimizu""].each {|name|  puts ""Hello!! #{name}."" }
```

こちらは慣れていけばすぐにハッシュか `each` かを見分けられるようになるので、心配しないでください。

# ハッシュの要素を編集
ハッシュは、定義した後にもデータを書き換えたり、追加したりといったことが可能です。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

# データの書き換え
params[:name] = ""Saitou""

# データの追加
params[:age] = 33

puts params[:name]
puts params[:age]

# 存在しないキーを指定するとnilになる
p params[:hobby]
```

出力結果

```
Saitou
33
nil
```

# ハッシュを使った繰り返し処理
配列と同様、ハッシュにも繰り返し処理を行うことができます。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

params.each do |key, value|
  puts ""キー：#{key}""
  puts ""バリュー：#{value}""
end
```

また、`each` メソッドのブロック引数の数を１つにすると、ハッシュの中にキーとバリューが格納されます。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

params.each do |key_value|
  # 配列を出力
  p key_value
end
```

引数をひとつにした場合は、キーとバリューが配列に格納されるので、以下のように出力することも可能になります。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

params.each do |key_value|
  # 配列を出力
  puts key_value[0]
  puts key_value[1]
end
```


# ハッシュの比較
ハッシュは、ハッシュ同士で比較を行うことができます。

キーとバリューが等しい場合は `true` を返し、そうでない場合は `false` を返します。

```ruby
params1 = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }
params2 = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

# trueが返る
puts params1 == params2

params3 = { name: ""Tanabe"", email: ""hoge@co.ne.jp"", address: ""Tokyo"" }
params4 = { name: ""Tanaka"", email: ""fuga@co.ne.jp"", address: ""Saitama"" }

# falseが返る
puts params1 == params2
```

# ハッシュのサイズを調べる
ハッシュのサイズを調べるには `size` メソッドを使用します。

```ruby
puts {}.size
puts { name: ""Tanabe"", email: ""hoge@co.ne.jp"", address: ""Tokyo"" }.size
```

実行結果

```
0
3
```

# 要素の削除
ハッシュの要素は、キーを指定して削除することができます。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

# nameを削除
params.delete(:name)

# ハッシュを表示
p params
```

実行結果

```
{:email=>""hoge@co.ne.jp"", :address=>""Saitama""}
```

また、削除しようとするキーがハッシュの中に存在しなかった場合は `nil` が返ってきます。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

# ageを削除
puts params.delete(:age)
```

実行結果

```
nil
```

`delete` メソッドに対してブロックを渡してあげると、指定したキーがなかった時に任意のメッセージを表示できるようになります。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

# ageを削除
puts params.delete(:age) {|key| ""#{key}というキーは存在しないため削除できませんでした""}
```

# シンボル
シンボルとは `:` の後に任意の名前をつけた文字列のような見た目のオブジェクトで、すでにここまでで学んできたハッシュのなかでも使っているものです。

```ruby
:name
```

このシンボルに関して、もっと理解を深めていきましょう。

シンボルは文字列とよく似ていますが、Rubyの内部では整数として扱われます。

そのため、２つの値が同じかどうかを比べる場合は、文字列よりも高速で処理を行うことができます。

```ruby
""name"" == ""name""
:name == :name
```

シンボルの特徴をまとめると以下のようになります。

- 見た目が文字列っぽいので読みやすい
- 内部的には整数なので処理が速い
- メモリの使用効率がいい
- 破壊的メソッドが使えないので値が勝手に変更される心配がない

そして、そのシンボルがよく使用されるのが、ご存知の通りハッシュです。

```ruby
{ name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }
```

また、ハッシュはキーとバリューの両方をシンボルにすることもできます。以下の2つのハッシュは、記述が違うだけで全く同じものとして認識されます。

```ruby
# シンボルのみ
{ name: :Tanaka, email: :hoge@co.ne.jp, address: :Saitama }
# => を使用した記述
{ :name => :Tanaka, :email => :hoge@co.ne.jp, :address => :Saitama }
```

一般的には、記述が楽なので以下の書き方がよく用いられます。

```ruby
# シンボルのみ
{ name: :Tanaka, email: :hoge@co.ne.jp, address: :Saitama }
```

# ハッシュのキーのみを取り出す
ハッシュのキーのみを取り出すときは以下のように記述します。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

params.each_key do |key|
  puts ""キー：#{key}""
end
```

実行結果

```
キー：name
キー：email
キー：address
```

# ハッシュのバリューのみを取り出す
ハッシュのキーのみを取り出すときは以下のように記述します。

```ruby
params = { name: ""Tanaka"", email: ""hoge@co.ne.jp"", address: ""Saitama"" }

params.each_value do |value|
  puts ""キー：#{value}""
end
```

実行結果

```
キー：Tanaka
キー：hoge@co.ne.jp
キー：Saitama
```

# キーとバリューの入れ替え
ハッシュのキーとバリューを入れ替えたいときは以下のように記述します。

```ruby
params = { ""name"" => ""Tanaka"", ""email"" => ""hoge@co.ne.jp"", ""address"" => ""Saitama"" }

puts params.invert
```

# まとめ
Ruby on Railsでもハッシュはよく利用しますが、バリエーションはそこまで多くはありません。基本的に、「値の取り出し」と「値の格納」が理解できれば最初は全く問題ないです。そこまで難しくないので、使い方を理解しておいてください；

お疲れ様でした！",2018-11-07 04:51:35 UTC,2018-12-02 06:55:02 UTC
19,Ruby,オブジェクト指向,"# オブジェクト指向の概要
オブジェクト指向とは、`設計図`から`物`を生み出すという考え方のことです。なぜこのような考え方をプログラミングに取り入れるのかというと、単純に開発効率が上がるからです。

このオブジェクト指向に関しては後の項目でも詳しく説明しているのですが、今後の学習をスムーズにするためにも知っておいたほうがいいので、以下に書いてあることだけでも理解できるようにしておきましょう。

プログラムの世界では、設計図のことを `クラス` 、設計図から生み出された物のことを `インスタンス（またはオブジェクト）` といいます。

|現実の世界|プログラムの世界|
|---|---|
|設計図|クラス|
|設計図から生み出された物|インスタンス（オブジェクト）|

本講座では混乱を避けるため、以降から「インスタンス」で話を進めていきます。

# オブジェクト指向を取り入れるメリット
オブジェクト指向を取り入れるメリットは、以下の点にあります。

- 設計図（クラス）を使いまわすことができる（コードを沢山書かなくて済む）
- 物（インスタンス）の質を一定に保つことができる（エラーの発生率を下げることができる）
- 物（インスタンス）のカスタマイズがしやすい（コードを書き換える量が少なくて済む）

これらのメリットにより、コードを書く量を大幅に減らすことができ、開発を効率よく進めることができます。

例えば、車だと設計図をもとに作りますよね？

だからこそ、同じような車を大量に作ることができたり、「1台だけハンドルが全く違う！」みたいなミスを防ぐことができたり、今回はボディーの部分だけ前よりかっこいいの作ってみる、なんてことが可能になるわけです。

「設計図をもとに物を作る」という発想には、こんなメリットがあるんですね。それをプログラミングに取り入れたのが、オブジェクト指向です。

# インスタンスの種類
Rubyには様々な種類のインスタンスが存在します。一部ではありますが、よく利用するインスタンスを以下にまとめておきます。全てを一度に覚える必要はありませんが、以下のインスタンスだけは頭に入れておいてください。

|クラス|インスタンス|説明|例|
|---|---|---|---|
|String|文字列|文字を表す|""文字列""|
|Integer|整数|整数を扱う|33|
|Float|少数|少数を扱う|1.5|
|Array|配列|複数のデータを格納して一度にたくさんのデータを扱うことができる|[""tanaka"",""saitou"",""aoyagi""]|
|Hash|ハッシュ|キーとバリューの組み合わせでデータを扱う|{name: ""tanaka"", age: 33, hobby: ""soccer""}|

# クラスとは
オブジェクト指向の部分でもクラスについては少し触れましたが、ここではより詳しく説明していきます。

クラスとは、私たちの世界でいう設計図にあたります。この設計図があることによって、効率よく開発を進めることができるのです。それでは、「車」を例にしてクラスについて学んでいきましょう。

もし、車を作るときに設計図を無しに作成したらどうなるでしょう？きっと、以下のような問題が発生するのではないでしょうか？

- 作るのに時間がかかる
- 品質にばらつきが出る
- カスタマイズがしにくい

クラスを利用しなかった場合、上記のような問題がプログラミングでも起こりうるわけです。これだと、開発効率も上がらないし、エラーが頻発するプログラムになってしまいます。それらの問題を防ぐために、オブジェクト指向を取り入れるわけです。

せっかくなので、車を例にコードを書いていきましょう。車には、値段や車体の色、乗車人数といった情報があります。それを、クラスを使わずに定義した場合は以下のようになります。

```ruby
# 値段
car_price = 1000000
# 車体の色
car_color = red
# 乗車人数
car_capacity = 4
```

1台の情報を表すだけなら大して問題はないかもしれません。ですが、これが10台となったらどうでしょう？

```ruby
car_price1 = 1000021
car_color1 = ""red""
car_capacity1 = 4
car_price2 = 1002000
car_color2 = ""blue""
car_capacity2 = 20
car_price3 = 3000000
car_color3 = ""green""
car_capacity3 = 6
car_price4 = 1500000
car_color4 = ""yellow""
car_capacity4 = 8
car_price5 = 8000000
car_color5 = ""red""
car_capacity5 = 6
car_price6 = 4000000
car_color6 = ""dark""
car_capacity6 = 4
car_price7 = 1030000
car_color7 = ""white""
car_capacity7 = 2
car_price8 = 1000930
car_color8 = ""green""
car_capacity8 = 4
car_price9 = 5000000
car_color9 = ""yellow""
car_capacity9 = 40
car_price10 = 3000000
car_color10 = ""red""
car_capacity10 = 8
```

10台の車に対する値段・色・乗車人数のたった3つの情報を表すだけでもこれだけの変数（30個）が必要になります。これがもし、50台も100代も生み出すことになったら、、、、。

スケールがどんどん大きくなるにつれ、クラスを使用しないとめんどくさいことが起こるようになります。

コードの記述量が増え、開発にかける労力が大きくなり、エラーが発生する確率も高まり、管理も難しくなる。コードの見通しも悪くなり、後々変更したいときにどう変更したらいいかわからない。そうなってしまっては、運用保守を行うプログラマーは地獄を見ますね。

それに対し、クラスを利用すると以下のようにすっきりとまとめることができます。これが、クラスを利用するメリット。

```ruby
# クラス：車の設計図
class Car
  attr_accessor :price, :color, :capacity

  def initialize(price, color, capacity)
    self.price = price
    self.color = color
    self.capacity = capacity
  end
end

# 設計図から生み出された車
car1 = Car.new(price: 1000021, color: ""red"", capacity: 4)
car2 = Car.new(price: 1002000, color: ""blue"", capacity: 20)
car3 = Car.new(price: 3000000, color: ""green"", capacity: 6)
car4 = Car.new(price: 1500000, color: ""yellow"", capacity: 8)
car5 = Car.new(price: 8000000, color: ""red"", capacity: 6)
car6 = Car.new(price: 4000000, color: ""dark"", capacity: 4)
car7 = Car.new(price: 1030000, color: ""white"", capacity: 2)
car8 = Car.new(price: 1000930, color: ""green"", capacity: 4)
car9 = Car.new(price: 5000000, color: ""yellow"", capacity: 40)
car10 = Car.new(price: 3000000, color: ""red"", capacity: 8)
```

見慣れないコードがたくさん出てきて混乱するかもしれませんが、とにかく今は変数の数が `car1~10` までと3分の1になったことに注目してください。

これらの変数の中に、値段・色・乗車人数など、車を構成する上で必要な情報がまとめて入っています。そうすることで、様々な情報の管理が楽になるわけです。

それでは、クラスの定義の仕方からすこしづつ学んでいきましょう。

# クラスの構成要素
クラスの構成要素は以下のようになっています。

|構成要素|用途|
|---|---|
|プロパティ|クラスが持つ情報|
|メソッド|クラスが持つ機能|
|initializeメソッド|プロパティの初期値の設定|

それぞれの構成要素に関しては、このあと詳しく説明します。今は以上のような構成要素でクラスが成り立っていることを理解しておいてください。

# クラスの定義とインスタンス化
では早速、クラスの定義をしてみましょう。クラスを定義するときは `class クラス名` で始まり `end` で終わります。それでは、 `Car` クラスを定義してみましょう。

```ruby
# クラスを定義
class Car

end
```

クラスが定義できたら、次はそのクラスからインスタンスを生み出します。このことをインスタンス化と言います。

`Car` クラスをインスタンス化するときは以下のように記述します。

```ruby
class Car

end

# クラスをインスタンス化
car = Car.new
```

上記のように、まずはクラスを定義し、そのクラスをインスタンス化することによって、実際にプログラムの中でクラスの持つ情報や機能を活用できるようになります。

クラスが定義できたら、次はその中にクラスの情報を保持する変数を定義する方法を学んでいきましょう。

# インスタンス変数
インスタンス変数は、クラスから作成されたインスタンスごとに独立して持つことができる変数です。この変数を利用することで、 `car1` では `color` が `red` 、 `car2` では `color` が `green` 、という風にインスタンスごとに保持する情報（プロパティー）を変えることができます。

インスタンス変数は、以下のように頭に@をつけて表します。

```ruby
class Car
  # インスタンス変数
  @color
end
```

# メソッド
定義したインスタンス変数に値を代入したい場合は、以下のようなメソッドを定義します。メソッドとは「一連の処理のかたまり」であり、前述した通り「クラスの機能」を定義するために使用されるものです。

```ruby
class Car
  # @name に値を代入
  def color=(color)
    @color = color
  end
end
```

定義したメソッドを利用する場合は、以下のようなコードを書きます。

```ruby
class Car
  def color=(color)
    @color = color
  end
end

car = Car.new

# Carクラスのcolorにredを代入
car.color = ""red""
```

また、`color`に代入した`red`を表示するためには、以下のようなメソッドを定義します。

```ruby
class Car
  # colorの値を表示するメソッド
  def color
    @color
  end

  def color=(color)
    @color = color
  end
end

car = Car.new
car.color = ""red""

# Carクラスのcolorに格納されたredの値を取得(putsで値を表示)
puts car.color
```

# initializeメソッド
initializeメソッドは、通常のメソッドとは異なり、クラスがインスタンス化された時に実行されるという特徴を持っています。

そのため、クラスの持つ情報（プロパティ）の初期値を設定する時に利用されます。

```ruby
class Car
  # initializeメソッドで初期値を設定
  def initialize
    @color = ""red""
  end

  def color
    @color
  end

  def color=(color)
    @color = color
  end
end

# インスタンス化された瞬間にinitializeメソッドが呼び出され
# colorにredが代入される
car = Car.new

# colorにredを代入する記述がいらなくなる
# car.color = ""red""

# colorを呼び出すとredが表示される
puts car.color
```

これで、わざわざ `color` に値を代入しなくても `red` が代入されるようになりました。ただ、今のままだと `color` には `red` しか代入されないようになっています。これを、インスタンスによって `green` や `blue` に変えるにはどうすればいいでしょう？

実は、インスタンス化をする際、 `initialize` メソッドには引数を渡すことができます。それにより、インスタンスごとに `color` の値を変更することが可能になるのです。

```ruby
class Car
  # initializeメソッドで初期値を設定
  def initialize(color)
    @color = color
  end

  def color
    @color
  end

  def color=(color)
    @color = color
  end
end

# インスタンス化する際にプロパティーに代入する値を渡す
car1 = Car.new(""red"")
car2 = Car.new(""green"")
car3 = Car.new(""blue"")

# colorにredを代入する記述がいらなくなる
# car.color = ""red""

# colorを呼び出すと代入された値が表示される
puts car1.color
puts car2.color
puts car3.color
```

実行結果

```
red
green
blue
```

# アクセサ（セッター、ゲッター）
Rubyのクラスでは、インスタンス変数に値を代入したり、値を取り出したりといった時に、専用のメソッドを定義していました。これらのメソッドのことをゲッター、セッターと言います。

|名前|役割|
|---|---|
|セッター|変数に値を代入する|
|ゲッター|変数から値を取り出す|

先ほどのサンプル内だと、以下のメソッドがゲッター、および、セッターにあたります。

```ruby
class Car

  def initialize(color)
    @color = color
  end

  # ゲッター
  def color
    @color
  end

  # セッター
  def color=(color)
    @color = color
  end
end
```

実は、このゲッターやセッターは、もっと簡単に記述することができます。その時に使用するのが、以下のメソッドです。

- attr_reader（ゲッター）
- attr_writer（セッター）

これらのコードを利用すると、クラスの定義はもっと簡潔に書けるようになります。

```ruby
class Car

  # ゲッター
  attr_reader :color
  # セッター
  attr_writer :color

  def initialize(color)
    @color = color
  end

end
```

このゲッターとセッターは、さらに簡潔にまとめることができます。

```ruby
class Car

  # セッター&ゲッター
  attr_accessor :color

  def initialize(color)
    @color = color
  end

end
```

このように、現場ではセッターとゲッターをまとめて定義できる`attr_accessor`が非常によく利用されます。裏側でどういうふうに処理がされているのかをきちんと理解し、`attr_accessor`を使えるようにしましょう。",2018-11-07 04:51:58 UTC,2018-12-03 11:08:27 UTC
20,Ruby,RSpec,"# RSpec
RSpecはRuby on Railsでテストを作成するための機能で、これを利用する事により簡単にテストコードを書くことができます。初心者の方からすると「テスト」といわれてもあまりピンとこないかもしれませんが、これ実装できると玄人受けはかなりいいです。つまり、面接で他の初心者に比べ結構優位に立てるということ。

ウェブアプリケーションの作成においては、デザインや裏側のロジックなど、華やかな部分に目がいきがちですが、システムの品質を担保し、自動でテストを行えるRSpecを使いこなせるのはかなり重要です。ぜひ、ここで基本的なことを理解しておいてください。

今回は、簡単にテストコードを実装できるようにRuby on Railsではなく、Ruby環境で実装できるようにしました。なので、気軽にサクッとRSpecを学んでいきましょう。

# 作業ディレクトリの作成
まずは、RSpecの練習をするためのディレクトリを作成します。ターミナルから以下のコマンドを実行しましょう。

```
mkdir rspec_sample
```

ディレクトリが作成できたら、その中に移動します。以下のコマンドを実行しましょう。

```
cd rspec_sample
```

# Gemfileを作成
次に、Ruby on Railsでも使用する`Gemfile`というものをつくります。`Gem`とは、様々な機能を簡単に実装するためにRuby on Railsに用意されたライブラリで、これを使用することによって開発効率が格段に上がります。では、以下のコマンドを実行してください。

```
bundle init
```

# gemをインストール
`Gemfile`が作成できたら、テキストエディタで`Gemfile`を開き、その内容を以下のとおりに書き換えてください。`rspec`という記述がテストコードを書くために必要なGemをさしています。

```ruby
gem ""rspec"", "">= 3.0.0""
```

`Gemfile`が作成できたら、gemをインストールしましょう。以下のコマンドをターミナルから実行してください。

```
bundle install
```

# RSpecを初期化
gemがインストールできたら、次にターミナルから以下のコマンドを実行し、`rspec`専用のファイルを作成します。

```
bundle exec rspec --init
```

コマンドを実行すると、以下のようなディレクトリやファイルが作成されます。

- .rspec
- spec/spec_helper.rb

# 簡単なテストコードを書く
`rspec`を使用するために必要なファイルやディレクトリが作成できたら、次に`rspec/spec`ディレクトリの中にある`spec_helper.rb`にテストコードを書いていきます。まずは、簡単なテストコードを書き、テストをするための感覚を掴んでいきましょう。以下のコードを`spec_helper.rb`に記述してください。

```ruby
describe '掛け算' do
  it '3 * 3 は 9 になること' do
    expect(3 * 3).to eq 9
  end
end
```

上のコードの中で`describe`の部分は「どういう内容のテストを行うのか？」を記述しています。また、`it`の部分には、テストの期待値を書きます。今回の場合は`3 * 3`の結果が`9`であることが期待値なので「3 * 3 は 9 になること」と書きました。

実際にテストを行うのが`expect(3 * 3).to eq 9`の部分になります。`expect`の中にテストを行いたい処理を記入し、`eq`の部分に実際に期待した値を書きます。

# テストを実行する
テストコードをかけたら、さっそく実行をして見ましょう。テストを行う際は、ターミナルから以下のコマンドを入力します。

```
bundle exec rspec
```

以下のような結果が表示されればテストは成功です。

```
......

Finished in 0.01085 seconds (files took 0.18722 seconds to load)
1 examples, 0 failures
```

`1 examples`の部分がおこなうテストの数です。そして、`0 failures`の部分が失敗したテストの数です。これが0なら、全てのテストが期待値通りの結果になったことを意味します。

# テストの対象となるクラスを作る
簡単なテストが実行できたら、次に本格的なテストコードの実装に移ります。まずは、`rspec_sample`ディレクトリ配下に`lib`ディレクトリを作りましょう。ここに、テストの対象となる`User`クラスを定義するためのファイルを作ります。では、`lib`ディレクトリ配下に`user.rb`を作りましょう。

`user.rb`が作成できたら、テキストエディタで開き、その中に`User`クラスを定義しましょう。

```ruby
class User
  attr_accessor :name, :age, :hobby

  def initialize(name:, age:, hobby:)
    self.name = name
    self.age = age
    self.hobby = hobby
  end

end
```

# 本格的にテストコードを書く
テスト用のクラスが作成できたら、それをテストするためのテストコードを書いていきます。まずは、以下のコードを`spec_helper.rb`に記述しましょう。

```ruby
# user.rb（テストの対象となるファイル）を読み込むための記述
require_relative '../lib/user'

# テストを実行するためのおきまりの書き方
RSpec.describe User do
  # テストの内容
  describe ""Userクラスの情報"" do
    # テストの期待値
    it ""return user name"" do
      # テスト対象となるUserクラスをオブジェクト化
      user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")
      # テストコード（名前が期待値と一致することを確認）
      expect(user.name).to eq ""Tanaka""
    end
    it ""return user age"" do
      user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")
      # テストコード（年齢が期待値と一致することを確認）
      expect(user.age).to eq 31
    end
    it ""return user hobby"" do
      user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")
      # テストコード（趣味が期待値と一致することを確認）
      expect(user.hobby).to eq ""Soccer""
    end
  end
end
```

上記のコードの中で、`require_relative '../lib/user'`は、user.rb（テストの対象となるファイル）を読み込むための記述です。

また、`user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")`の部分は、`name`に`Tanaka`、`age`に`31`、`hobby`に`Soccer`を格納しています。これが、テストの対象となるクラスのオブジェクトです。

`expect(user.name).to eq ""Tanaka""`の部分が実際のテストコードになるのですが、中身は単純にこれまでの基礎で学んできたコードと同じ考え方で大丈夫です。`user.name`の記述は、`User`クラスのオブジェクトである`user`の`name`の値を取り出す記述になります。それが、期待値である`eq ""Tanaka""`と一致するかどうかを確かめるコードとなるわけです。

上記のテストコードがかけたら、テストを実行して見ましょう。その際は、ターミナルから以下のコードを入力するのでしたね。

```
bundle exec rspec
```

以下のような結果が表示されればテストは成功です。

```
......

Finished in 0.01085 seconds (files took 0.18722 seconds to load)
3 examples, 0 failures
```

これで基本的なテストコードの書き方は学ぶことができました。しかし、`RSpec`には他にも色々な書き方があり、それをいきなり現場で見ると混乱することになります。なので、他の書き方についてもきちんと理解し、現場でもコードを書いたり読んだりといったことができるようにしましょう。

## context
`context`はテストをグループ分けするために使用するものです。以下のコードを`spec_helper.rb`に記述し、`context`でグループ分けしたコードを書いてみましょう。

```ruby
require_relative '../lib/user'

RSpec.describe User do
  describe ""Userクラスの情報"" do
    # 名前がTanakaの場合のUserオブジェクトに対するテスト
    context ""名前がTanakaの場合"" do
      it ""return user name"" do
        user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")
        expect(user.name).to eq ""Tanaka""
      end
      it ""return user age"" do
        user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        user = User.new(name: ""Tanaka"", age: 31, hobby: ""Soccer"")
        expect(user.hobby).to eq ""Soccer""
      end
    end
    # 名前がSuzukiの場合のUserオブジェクトに対するテスト
    context ""名前がSuzukiの場合"" do
      it ""return user name"" do
        user = User.new(name: ""Suzuki"", age: 31, hobby: ""Soccer"")
        expect(user.name).to eq ""Suzuki""
      end
      it ""return user age"" do
        user = User.new(name: ""Suzuki"", age: 31, hobby: ""Soccer"")
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        user = User.new(name: ""Suzuki"", age: 31, hobby: ""Soccer"")
        expect(user.hobby).to eq ""Soccer""
      end
    end
  end
end
```

## before
`before`はテストの下準備をするためのコードです。つまり、テストに必要なオブジェクトの下準備をする際に`let`を使用します。

```ruby
require_relative '../lib/user'

RSpec.describe User do
  describe ""Userクラスの情報"" do
    context ""名前がTanakaの場合"" do
      # テストの前準備をする
      before do
        @params = {name: ""Tanaka"", age: 31, hobby: ""Soccer""}
      end
      it ""return user name"" do
        user = User.new(@params)
        expect(user.name).to eq ""Tanaka""
      end
      it ""return user age"" do
        user = User.new(@params)
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        user = User.new(@params)
        expect(user.hobby).to eq ""Soccer""
      end
    end
    context ""名前がSuzukiの場合"" do
      # テストの前準備をする
      before do
        @params2 = {name: ""Suzuki"", age: 31, hobby: ""Soccer""}
      end
      it ""return user name"" do
        user = User.new(@params2)
        expect(user.name).to eq ""Suzuki""
      end
      it ""return user age"" do
        user = User.new(@params2)
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        user = User.new(@params2)
        expect(user.hobby).to eq ""Soccer""
      end
    end
  end
end
```

## let
`let`を使用すると、インスタンス変数`@params`を置き換えることができます。

```ruby
require_relative '../lib/user'

RSpec.describe User do
  describe ""Userクラスの情報"" do
    # paramsにオブジェクトに必要な情報を格納する
    let(:params) {{name: ""Tanaka"", age: 31, hobby: ""Soccer""}}
    # params2にオブジェクトに必要な情報を格納する
    let(:params2) {{name: ""Suzuki"", age: 31, hobby: ""Soccer""}}
    context ""名前がTanakaの場合"" do
      it ""return user name"" do
        # paramsの値を使用してオブジェクトを作成する
        user = User.new(params)
        expect(user.name).to eq ""Tanaka""
      end
      it ""return user age"" do
        # paramsの値を使用してオブジェクトを作成する
        user = User.new(params)
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        # paramsの値を使用してオブジェクトを作成する
        user = User.new(params)
        expect(user.hobby).to eq ""Soccer""
      end
    end
    context ""名前がSuzukiの場合"" do
      it ""return user name"" do
        # params2の値を使用してオブジェクトを作成する
        user = User.new(params2)
        expect(user.name).to eq ""Suzuki""
      end
      it ""return user age"" do
        # params2の値を使用してオブジェクトを作成する
        user = User.new(params2)
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        # params2の値を使用してオブジェクトを作成する
        user = User.new(params2)
        expect(user.hobby).to eq ""Soccer""
      end
    end
  end
end

```

## before, merge!
`before`と`merge!`で、テストごとに異なるパラメータのみを後から追加することができます。これでだいぶテストコードが柔軟にかけるようになります。

```ruby
require_relative '../lib/user'

RSpec.describe User do
  describe ""Userクラスの情報"" do
    let(:params) {{age: 31, hobby: ""Soccer""}}
    context ""名前がTanakaの場合"" do
      # beforeを追加
      before do
        # paramsにTanakaを追加
        params.merge!(name: ""Tanaka"")
      end
      it ""return user name"" do
        user = User.new(params)
        expect(user.name).to eq ""Tanaka""
      end
      it ""return user age"" do
        user = User.new(params)
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        user = User.new(params)
        expect(user.hobby).to eq ""Soccer""
      end
    end
    context ""名前がSuzukiの場合"" do
      # beforeを追加
      before do
        # paramsのnameに紐づく値をSuzukiに変更
        params.merge!(name: ""Suzuki"")
      end
      it ""return user name"" do
        user = User.new(params)
        expect(user.name).to eq ""Suzuki""
      end
      it ""return user age"" do
        user = User.new(params)
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        user = User.new(params)
        expect(user.hobby).to eq ""Soccer""
      end
    end
  end
end
```

## letを利用したオブジェクトの変数化
`User`クラスのインスタンス化の部分を`let`に置き換え、変数として利用します。

```ruby
require_relative '../lib/user'

RSpec.describe User do
  describe ""Userクラスの情報"" do
    # Userもletで定義
    let(:user) { User.new(params) }
    let(:params) {{age: 31, hobby: ""Soccer""}}
    context ""名前がTanakaの場合"" do
      before do
        params.merge!(name: ""Tanaka"")
      end
      it ""return user name"" do
        # letで定義したuserを使用
        expect(user.name).to eq ""Tanaka""
      end
      it ""return user age"" do
        # letで定義したuserを使用
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        # letで定義したuserを使用
        expect(user.hobby).to eq ""Soccer""
      end
    end
    context ""名前がSuzukiの場合"" do
      before do
        params.merge!(name: ""Suzuki"")
      end
      it ""return user name"" do
        # letで定義したuserを使用
        expect(user.name).to eq ""Suzuki""
      end
      it ""return user age"" do
        # letで定義したuserを使用
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        # letで定義したuserを使用
        expect(user.hobby).to eq ""Soccer""
      end
    end
  end
end
```

## オブジェクトのパラメータの一部をletで変数化
`User`のパラメータも`let`を利用すると変数で設定することができます。試しに、`name`を`let`に置き換えてみましょう。

```ruby
require_relative '../lib/user'

RSpec.describe User do
  describe ""Userクラスの情報"" do
    let(:user) { User.new(params) }
    # nameを変数として読み込む
    let(:params) {{name: name, age: 31, hobby: ""Soccer""}}
    context ""名前がTanakaの場合"" do
      # letを使ってnameを変数として定義する
      let(:name) { ""Tanaka"" }
      it ""return user name"" do
        expect(user.name).to eq ""Tanaka""
      end
      it ""return user age"" do
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        expect(user.hobby).to eq ""Soccer""
      end
    end
    context ""名前がSuzukiの場合"" do
      # letを使ってnameを変数として定義する
      let(:name) { ""Suzuki"" }
      it ""return user name"" do
        expect(user.name).to eq ""Suzuki""
      end
      it ""return user age"" do
        expect(user.age).to eq 31
      end
      it ""return user hobby"" do
        expect(user.hobby).to eq ""Soccer""
      end
    end
  end
end
```

# まとめ
`RSpec`には様々な書き方があり最初は混乱するかと思いますが、現場ではほぼ必ず使用する技術です。なので、すこしずつ着実に身につけていきましょう。これが実装できることをアピールすると、面接でもかなり印象が良くなります。

製品の品質を効率よく担保するためにも、自身の転職を成功させるためにも、ぜひしっかりと学んでいってください。",2018-11-07 04:52:26 UTC,2018-12-02 07:05:57 UTC
21,SQL,SQLの基本,"# SQL
SQLとは、データベースの定義や操作を行うための言語です。
このSQLを使いこなすことによって、データの検索機能を実装できるようになります。

また、データ一覧表示、新規登録、削除、更新などの処理も、このSQLによって行われます。

Ruby on Railsでは、Active Record が自動で最適なSQLを発行してくれるため、特に意識しなくても簡単なアプリなら作成できてしまいます。

しかし、現場ではSQLを直書きすることもあるので、ぜひ、きちんと理解できるようにしておいて下さい。
そうすると、現場での開発もスムーズに進むことが多くなります。

## SQLのダウンロード（Mac）
MySQLは `Homebrew` を使用してダウンロードします。 `Homebrew` をインストールしていない方は、以下のコマンドをターミナルから実行しましょう。

```
/usr/bin/ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
```

`Homebrew` がインストールできたら、 `MySQL` をインストールします。次のコマンドを順番に実行してください。

```
brew update
```

```
brew install mysql
```

処理が終わればMySQLのインストールは完了です。

## MySQLの起動
MySQLは、以下のコマンドを実行して起動しましょう。

```
mysql.server start
```

次に、ログインをします。以下のコマンドを実行しましょう。

```
mysql -u root -p
```

そうするとパスワードの入力が求められますが、MySQLのインストール時にパスワードを設定していない場合は、特に何も入力せず`Enter`を押して大丈夫です。

それでは早速、MySQLを使用してSQLを実行していきましょう。

## テーブルの作成
まずは、練習に使用する`sql_sample`データベースを作成します。

```sql
create database sql_sample;
```

データベースが作成できたら、そのデータベースを選択するために以下のコマンドを実行しましょう。

```sql
use sql_sample;
```

データベースが選択できたら、 `users` テーブルを作成します。

```sql
create table users(id int, name varchar(255));
```

コマンドが実行できたら、きちんと `users` テーブルが作成できているか確認してみましょう。

```sql
show tables;
```

以下のように `users` テーブルが表示されると作成は成功です。

```
+----------------------+
| Tables_in_sql_sample |
+----------------------+
| users                |
+----------------------+
```

テーブルが確認できたら、サンプルデータを作成します。以下のコマンドを実行しましょう。本当は１行ずつ手入力していただきたいのですが、めんどくさい場合は１行目のみ手入力で実行し、２行目以降はコピペで実行してみてください。

```sql
insert into users (id, name) VALUES (1, 'Tanaka');
insert into users (id, name) VALUES (2, 'Takahashi');
insert into users (id, name) VALUES (3, 'Nakamura');
insert into users (id, name) VALUES (4, 'Tanaka');
```

データが作成できたら、様々なコマンドを実行して動作を確認していきましょう。

## select
`select` は、データベースからデータを検索するためのコマンドで、最もよく利用されるものです。

```sql
select * from users;
```

上記のコマンドの中で `*` の部分は、「全てのデータ」という意味になります。そのため、上記のコマンドを実行すると `users` テーブルから全てのデータを検索することになります。

## distinct
`distinct` は重複するデータを除外してデータを検索することができます。

```sql
select distinct name from users;
```

## order by
`order by` はデータを表示する順番を指定することができます。データの表示を昇順にする場合は、 `order by` に合わせて `asc` を使用します。

```sql
select * from users order by id asc;
```

データの表示を昇順にする場合は、 `order by` に合わせて `desc` を使用します。

```sql
select * from users order by id desc;
```

|SQL|順番|
|---|---|
|asc|昇順|
|desc|降順|

## like
`like` は、データをあいまい検索する時に使用します。検索したいデータを `%` で囲むと、その文字を含むデータを検索することができます。そのため、今回のコマンドだと `name` に `m` が含まれるデータを検索します。ちなみに、この `%` のことをワイルドカードと呼びます。

```sql
select * from users where name like '%m%';
```

`id` を指定してデータを検索することもできます。

```sql
select * from users where id = 3;
```

## between
`between` は、範囲指定で条件検索を行う時に使用します。

```sql
select * from users where id between 2 and 4;
```

## and
`and` は複数の条件を満たすデータの検索をする時に使用します。

```sql
select * from users where id = 2 and name = 'Takahashi';
```

## or
`or` はどちらかの条件を満たすデータを検索する時に使用します。

```sql
select * from users where id = 2 or name = 'Tanaka';
```

## as
`as` は列やテーブルに別名をつけます。これを使用することによって、検索結果の表示を変えることができます。

```sql
select id as No, name as 名前 from users;
```

## in/not in
`in/not in` は、複数の値を指定して条件検索を行う時に使用します。

```sql
select * from users where name in ('Takahashi', 'Tanaka');
```

`not in` だと、「指定した条件を含まない」という意味になります。

```sql
select * from users where name not in ('Takahashi', 'Tanaka');
```


## limit
`limit` は検索数を制限する時に使用します。

```sql
select * from users where id = 2 or name = 'Tanaka' limit 2;
```

## update
`update` はデータベースのデータを更新する時に使用します。

```sql
update users set name = 'Tanabe' where name = 'Takahashi';
```

## case
`case`は条件に応じて実行するSQLを指定したい時に使用します。

```sql
select id, name,
    case name when 'Tanaka' then '関係者'
              when 'Takahashi' then '関係者'
              else '部外者'
    end as 分類
from users;
```

## まとめ
初心者の方はあんまりSQLを学ぶことを優先しないのですが、たとえRuby on Railsを使おうと、現場ではSQLを記述することがあります。それに、Ruby on Railsでデータ検索をする際も、裏側ではSQLが発行されています。

そのため、Ruby on Railsの理解を深めるためにも、最低限のSQLを理解できるようにしましょう。スラスラ書けるようになる必要はないので、せめて読めるようにはしてみてください。それだけでも、だいぶRuby on Railsの動きが把握できるようになりますよ。",2018-11-07 04:53:11 UTC,2018-11-07 04:53:11 UTC
22,Ruby on Rails,Ruby on Rails の基本,"# Ruby on Rails（概論）
こちらでは、コードを書くのではなくRuby on Railsがどういうものなのかを説明することに焦点を当てます。今後、Ruby on Railsのスキルを身につける上で、基本的な仕組みを知っておくことは超重要。基礎の基礎が大事ということをよく頭に入れながら学んでいきましょう。

# MVC
Ruby on Railsは、MVCアーキテクチャにのっとって設計されています。そのため、MVCアーキテクチャを理解しておくことがとても重要になって来るのです。ちなみに、MVCのそれぞれの意味はM（モデル）、V（ビュー）、C（コントローラー）となります。そして、これらの要素はRuby on Railsにおいて明確に役割が決まっています。

|名前|役割|
|---|---|
|M(モデル)|データベースのデータを扱う、複雑なロジックを組む|
|V(ビュー)|Webサイトの画面を構成|
|C(コントローラー)|処理の振り分け|

# Ruby on Railsの構成要素
Ruby on Railsには、様々な構成要素があります。そのなかでも、まずは基本となる以下の構成要素を覚えておきましょう。

1. Active Record（モデル）
2. Action View（ビュー）
3. Action Controller（コントローラー）

# Ruby on Railsの便利な機能
Ruby on Railsがなぜ便利なのか？その秘密がこちらです。

## ルーティング
&や=、拡張子の入った汚いURLではなく、`/user/1`などの綺麗でなんのデータを見ているのかわかりやすいURLを使用することができます。

## テンプレート
Ruby on Railsでは、Webサイトのナビゲーションバーなどを全体で共有したり、HTMLの中に直接Rubyのコードを埋め込んだりすることができます。これにより、同じコードをなんども書く手間が省けたり、柔軟に画面の表示を変えることが可能になるわけです。

## マイグレーション
マイグレーションとはデータベースのテーブルを定義するための機能で、この機能によりデータベースを操作するための言語であるSQLを直接書かなくても自由にテーブルを作成できるようになります

## レコードの操作
データベースに保存されているデータのかたまり（レコード）を簡単に操作することができます。これにより、データの一覧表示、登録、更新、削除といったデータを扱うための操作（CRUD処理）が実現しやすくなっています。

## バリデーション
データベースのテーブルにデータを保存するときに、データのチェックを行うことができます。例えば、数字になっているか？空のデータになっていないか？データが長すぎないか？といったチェックを簡単に行えるようになるわけです。

## 国際化
様々な言語に対応したWebサイトを構築することができます。

## テスト
Webサイトの品質を保つのに重要なテストが簡単に実装できます。

## セッション
複数ページにまたがって、同一ユーザーのデータを保持する（例：アマゾンのショッピングカート）といった機能が簡単に実現できます。

## モデル間の関連付け
複数のモデル間で連携し、データの検索を行う際にいちどに複数のテーブルのデータを取り出すことが可能になります。例えば、あるユーザーの購入した商品一覧を表示するときにも、この関連付けが役に立ちます。

# HTTP
 HTTPは、ブラウザとサーバーがHTML、画像などの情報をやり取りするときに使われる通信手段（プロトコル）です。Webサイトを作成する際にも、この点を理解しながら進めていきましょう。

## リクエストとレスポンス
Webサイトではリクエストとレスポンスによって情報の送受信が行われています。リクエストは、ユーザーがブラウザから要求するもので、レスポンスはユーザーの要求に応じて必要なデータを返すことです。このやりとりによって、Webサイトはユーザーに必要な情報を届けることができています。

|名前|意味|
|---|---|
|リクエスト|ユーザーがサーバーに対してデータを要求すること|
|レスポンス|ユーザーのリクエストに応じた情報をサーバーが返すこと|

# Ruby on Railsのリクエストの流れ
Webアプリケーションを作成するにあたって、リクエストの流れを理解することは超重要です。今後の学習をスムーズに進めるためにも、この流れをよく理解しておきましょう。Ruby on Railsにおいて、ユーザーからのリクエストは以下の流れで処理されます。

1. ルート
2. コントローラ
3. ビュー

Ruby on Railsはブラウザからのリクエストを受け取ると、`config`ディレクトリの中にある`routes.rb`の記述に従ってどのコントローラのどのアクションに処理を渡すかを決めます。

コントローラは複数あり、そのコントローラの中に複数のアクションがあります。そして、アクションにはモデルとどのようなやり取りをするのかを記述します。また、モデルから取り出したデータはインスタンス変数に保存し、その情報をビューに渡します。アクションは、ブラウザへのレスポンスを作成するために、表示するビューを選択します。特に指定がない場合は、アクションと同じ名前のビューが選択されて、ブラウザに表示されます。

このコントローラによって、モデルからデータを受け取ったり、次にどのビューを表示させるかを決めたりすることができるわけです。

コントローラによって選ばれたビュー（テンプレートともいう）は、コントローラのインスタンス変数を参照して、その値をHTMLの中で使用することができます。それにより、ユーザーが要求したデータを柔軟に表示させることができるわけです。",2018-11-07 04:53:53 UTC,2018-11-07 04:53:53 UTC
23,Ruby on Rails,Ruby on Rails の環境構築,"# Ruby on Rails
Rubyを利用して効率よくWebサイトを開発できるようにしてくれるものです。
このように、開発こ効率をあげてくれるものを「フレームワーク」と言います。

つまり、「Ruby on Railsは、Rubyのフレームワーク」ということになります。

## インストールの流れ

1. Xcodeのインストール
2. Command Line Tools
3. Homebrew
4. rbenv(アールベンブ), ruby-build(ルビー・ビルド)
5. readline
6. MySQL
7. bundler
8. Ruby on Rails

## Xcodeのインストール
まずは`AppStore`にて`Xcode`のインストールを行いましょう。
`AppStore`は、Macのアプリをインストールするためのプラットフォームです。

以下の手順でXcodeをダウンロードしましょう。

1. Finderを開く
2. 「アプリケーション」に移動
3. AppStoreを開く
4. 「Xcode」と検索
5. Xcodeをダウンロード

## Commandlinetoolのインストール
次に、[AppleのDevelopperサイト](https://developer.apple.com/download/more/)から`Command LineTool`をインストールします。

もし、認証チェック画面が出たら、以下の手順を実行しましょう。認証チェックが表示されない場合は、4番と5番を実行してください。

1. チェックボックスにチェックしてsubmit
2. download tools
3. see more downloads
4. 左上の検索窓で`command`と入力して検索
5. 自分のOSのバージョンにあった`Command LineTool`をインストール。

## Homebrewのインストール
Homebrewのインストールをします。ここからはターミナルでコマンドを入力していきましょう。

```
ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
```

途中で`enter`を求められるので`enterキー`を押し、その後、Macのパスワードを入力しましょう。


homebrewがきちんとインストールできたかバージョンを確認します。

```
brew -v
```

homebrewのアップデート

```
brew update
```

## 権限の変更
`/usr/local/bin`フォルダの権限を変更します。

```
sudo chown -R `whoami`:admin /usr/local/bin
```

## rbenv(アールベンブ), ruby-build(ルビー・ビルド)のインストール
次に、rbenv(アールベンブ), ruby-build(ルビー・ビルド)をインストールしましょう。ruby-buildはRubyの様々なバージョン(2.4.1など)をインストールすることができるツールで、rbenvは、rubyのバージョンを切り替えるためのツールです。

インストールはHomebrewを使用して行います。以下のコマンドを実行しましょう。

```
brew install rbenv ruby-build
```

rbenvのパスを通す

```
echo 'eval ""$(rbenv init -)""' >> ~/.bash_profile
```

bash_profileの変更内容を読み込む

```
source ~/.bash_profile
```

## readlineのinstall
readlineはCUIでの操作を簡単にするためのツールです。

```
brew install readline
```

readlineのパスを通す

```
brew link readline --force
```

## Ruby【ver.2.5.1：最新安定板】のインストール
readlineとrbenvを利用して`Ruby ver.2.5.1`のインストールを行います。

```
RUBY_CONFIGURE_OPTS=""--with-readline-dir=$(brew --prefix readline)""
```
```
rbenv install 2.5.1
```

インストールが完了したらリハッシュします。

```
rbenv rehash
```

rbenvを用いて利用するRubyのバージョンを決めます。

```
rbenv global 2.5.1
```

Rubyのバージョンを確認し、インストールが成功しているか確かめましょう。

```
ruby -v
```

## MySQLのインストール
MySQLとは、フリーのデータベース管理ソフトです。
データベース管理ソフトの中でも圧倒的なシェアを誇るのはOracleですが、それは有料なのでMySQLやPostgreSQLなどのフリーソフトを利用することが多いです。

どのデータベース管理ソフトでもSQL文でデータを取り扱うのは一緒なので、覚えておくと様々なデータベース管理ソフトに応用が利きます。
Homebrewを利用してMySQLのインストールを行います。

```
brew install mysql56 mysql
```

MySQLはデフォルトの状態では自動で起動しないようになっています。毎回、起動コマンドを打つのは大変なので、自動で起動するように設定しましょう。以下のコマンドを順に入力してください。

```
mkdir ~/Library/LaunchAgents
```
```
ln -sfv /usr/local/opt/mysql\@5.6/*.plist ~/Library/LaunchAgents
```
```
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql\@5.6.plist
```


## bundlerのインストール
次に、Rubyのgemであるbundlerをインストールします。

```
gem install bundler
```

## Ruby on Railsのインストール
次にRubyのgemでありフレームワークでもある`Ruby on Rails`をインストールします。

```
gem install rails
```

gemをインストールしたのでrehashを行います。

```
rbenv rehash
```

インストールがうまくいったかどうか確かめるため、以下のコマンドを入力してRailsのバージョンを確認しましょう。きちんとバージョンが表示されればインストールは成功です。

```
rails -v
```

## 注意!!
Xcodeのインストールが完了していないのに `gem install rails` を実行するとインストールがうまくいきません。エラーが出た場合は、Xcodeがきちんとインストールされていること、最新版にアップデートされていることを確認しましょう。",2018-11-07 04:54:38 UTC,2018-11-07 04:54:38 UTC
24,Ruby on Rails,Ruby on Rails で Hello World!!,"# Webアプリケーションとは
WEBアプリケーションとは、ブラウザから利用可能な動的なWebサービスのことを指します。 動的Webサービスとは何かというと、ユーザーの利用状況によって柔軟に画面や表示内容が変わるサービスのことです。例えば、会社のホームページとFacebookやTwitterなどを比べてみるとよくわかるかとお思います。会社のホームページは何度訪れても画面になんの変化もありません。それに対し、FacebookやTwitterはユーザの登録情報や投稿内容によってまったく表示が異なります。このように、動的に変化するのがWebアプリケーションの特徴です。

# リクエストとレスポンス
Webアプリケーションでは、リクエストとレスポンスという概念が存在します。`リクエスト`はユーザーからの要求のことで、ボタンをクリックしたり、URLを入力してアクセスしたときにリクエストが発生します。`レスポンス`はアプリの応答のことで、ユーザーが要求したデータを表示するときにサーバーからレスポンスが送信されます。

- ユーザの要求 => リクエスト
- アプリの応答 => レスポンス

# Railsアプリの構成
Railsアプリの構成は、初心者にとってはかなり複雑な印象があるかと思います。でも、きちんと以下の構成になっていることを頭に入れておけば、この後の学習もだいぶスムーズになるので、よく確認して見てください。

- Rails（アプリの本体）
 - ルート
 - コントローラ
 - モデル
 - ビュー
- データベース（MySQL, Postgre, SQLiteなど）

# 今回作成するアプリ
今回作成するのは、`Hello World`を表示するだけの簡単なアプリです。このアプリを通して、ルート・コントローラ・ビューの作成方法をしっかりと身につけましょう。このレッスンの内容が、これからRailsアプリケーションを作成するための土台となります。大切な部分なので、一つ一つ確認しながら進めていってください。

## 実装する機能
- ユーザー登録
- ユーザー一覧表示
- ユーザー情報の更新
- ユーザーの削除

# Railsアプリの処理の順番
Railsアプリにユーザーからアクセスがあった場合、アプリ内で以下のように処理されます。

1. リクエスト：ユーザーからのリクエスト
2. ルート：コントローラのアクションを指定
3. コントローラ：モデルやビューへの処理の振り分け
4. ビュー：画面の表示

# アプリ立ち上げの流れ
慣れないうちは、アプリを立ち上げたら以下の流れで初期画面が表示されるか確認してください。

1. `rails new`コマンド
2. `rake db:create`（データベースの作成）
3. `rails s`（サーバを立ち上げ）
4. [http://localhost:3000/](http://localhost:3000/)にアクセス

データベースの種類を指定してアプリを立ち上げる時は、以下のようにコマンドを実行します。

例）`sample`という名前のアプリを作成する

```
rails new sample
```

そうすると、`sample`という名前のディレクトリが作成され、そのなかに様々なディレクトリやファイルが作成されます。今の時点で全てを把握する必要はありませんが、自動的に作成されるディレクトリのうち、以下のものだけしっかりと役割を理解しておいてください。

|ディレクトリ|役割|
|---|---|
|app|モデル、ビュー、コントローラを管理|
|config|ルーティング、データベースなどの設定ファイルの管理|
|db|マイグレーションファイル、シードデータファイルの管理|

`Ruby on Rails`はディレクトリ階層が厳しく管理されているので、その階層構造をしっかりと守って開発しなければならないということを理解しておきましょう。

# データベースを作成する
アプリを立ち上げることができたら、新しくディレクトリができています。ディレクトリとは、パソコンでよく利用するフォルダと同じだと思っていただいて大丈夫です。プログラミングの世界では、フォルダのことをディレクトリと表現します。

では、立ち上げたアプリのディレクトリに移動しましょう。今回は、`sample`という名前のアプリを作成したので、`sample`ディレクトリが作成されているかと思います。その中に移動する時は、以下のコマンドを実行します。

```
cd sample
```

`cd sample`の`cd`は、`change directory`という意味になります。つまり、使用するディレクトリを変更するということですね。このように、どういう単語の略なのかを考えると、コマンドもだいぶ覚えやすくなります。

アプリのディレクトリに移動できたら、次はアプリに対応するデータベースを作成しましょう。データベースを作成すると言っても、そこまで難しく考える必要はありません。短いコマンドを実行するだけで、簡単にデータベースが作成できます。

# データベースの作成
データベースとは、Webアプリケーションの中で使用されるデータを整理整頓し、管理するためのものです。立ち上げたアプリに関連するデータベースを作成する場合は、以下のコマンドを実行するだけでOKです。

```
bundle exec rake db:create
```


また、このコマンドは一度実行した後は再度実行する必要はありません。すでにデータベースが作成されたアプリでは、すでにデータベースを使える準備ができているので、最初の一回だけ実行するようにしましょう。（もし実行してもエラーが表示されるだけでアプリが壊れることはありません）

アプリを作成したら、Webサーバを起動しましょう。RailsアプリはWebアプリケーションなので、Webサーバーが起動していないと動作を確認することができません。そのため、以下のコマンドを実行してWebサーバーを立ち上げましょう。ちなみに、Railsに付属しているWebサーバーは`WEBrick`と呼ばれています。

```
rails s
```

サーバーが起動できたら、初期画面へアクセスしてみましょう。以下のリンクから、初期画面へアクセスすることができます。

[http://localhost:3000/](http://localhost:3000/)


# MVCモデルの理解
`MVCモデル`は、Railsアプリを開発する上でとても重要な概念です。MVCというアルファベットのそれぞれの意味は以下の通りです。ちょっと難しい部分なので、今はさらっと読んでおくだけで大丈夫です。

|頭文字|読み|役割|
|---|---|---|
|M|モデル|データベースとのデータのやり取り、複雑なロジックを記述、バリデーションの設定|
|V|ビュー|ユーザーの目に触れる部分|
|C|コントローラ|処理の振り分け|

MVCモデルでは、以上のようにプログラムが明確に役割分担されています。それによって、コードの管理、運用保守が簡単に行えるようにしています。例えば、プログラミングのわからないデザイナーでもビューの部分だけなら編集ができるようになったり、処理の振り分けを変えたいならコントローラの部分の記述だけを変えたりと、どこのコードを編集すればいいかを明確にできたり、一部のコードを変更しても他の部分のコードの変更が最小限に抑えられるようになるのです。


# Railsアプリ開発の流れ
Railsアプリを開発する時は、以下の流れで行います。今後ずっと行うことになる重要な流れなので、ぜひしっかりと頭に入れておいてください。

1. ルートを作成
2. コントローラを作成
3. ビューを作成

とにかく、ルート・コントローラ・ビューの順番で設定を行うということを頭に入れておいてください。これがRailsアプリ開発の超重要な手順になります。

## ルートの作成
では早速、手順1のルートの作成から始めていきましょう。まずはファイルのある場所をしっかりと覚えてください。ルートを設定するためのファイルは`config`ディレクトリの中にあります。

```
config/routes.rb
```

ファイルが確認できたら、その中にルートを設定しましょう。ルートを設定する際は、`アクセスされるURL`、`そのURLに対応するコントローラ`、`指定したコントローラのアクション`を記述します。以下は、ルートを設定するときの一つの例です。

```ruby
# 左側がURL　右側がコントローラの名前とアクション
get '/users', to: 'users#index'
```

上の例は以下のような構成になっています。

```
HTTPリクエスト 'ユーザーが指定するURL', to: 'コントローラー名#アクション名'
```

これが基本的な書き方なので、ぜひ頭に入れておいてください。また、ここで出てきたHTTPリクエストには以下のような種類があります。

# コントローラの作成
先ほど、ルートの設定の部分で以下のように記述しました。

```ruby
# 左側がURL　右側がコントローラの名前とアクション
get '/users', to: 'users#index'
```

このとき、ユーザーが`/users`にアクセスすると、`users`コントローラの`index`アクションに処理が移るということになります。そのため、次は`users`コントローラを作成し、その中に`index`アクションを追加しましょう。

まずは、コントローラを作成するために以下のコマンドをターミナルで実行します。

```
rails g controller users
```

上のコードの構成は以下のようになります。`controller_name`の部分には、自分が作成したいコントローラ名を入力してください。また、Railsのルールとして、コントローラ名(`controller_name`の部分)は複数形にすることが推奨されます。

```
rails g controller controller_name
```

`rails g controller users`を実行すると、以下の場所に`users_controller.rb`というコントローラのファイルができています。テキストエディタから、以下のファイルが作成されているか確認してみましょう。

```
app/controller/users_controller.rb
```

コントローラが作成できたら、次にアクションを追加します。ルートの設定の部分で`users`コントローラに対して`index`アクションを指定したので、ファイルの中に`index`アクションを定義します。以下のようにコードを書いてみましょう。

```ruby
  # indexがアクション名
  def index

  end
```


上の記述がアクションの基本的な設定方法になります。基本的な構成として`def`と`end`で囲み、ルートの指定に対応するアクション名を定義してあげます。

```ruby
  def アクション名

  end
```

# ビューの作成
コントローラのアクションが定義できたら、そのアクションに対応するビューを作成しましょう。ビューファイルは以下の場所で管理されています。

```
app/views
```

その中に、デフォルトで`layouts`というディレクトリが存在します。また、そのほかにも`users`というディレクトリが存在するかと思います。このディレクトリは、先ほど`rails g controller users`というコマンドを実行した時に作成されたものです。つまり、コントローラを作成すると、それに対応するビューのディレクトリも一緒に作成されるということです。

ビューファイルは、コントローラのアクションに対応する名前にします。今回のサンプルであれば、`users`コントローラの`index`アクションに対応するビューファイルを作成するので、`app/views/users`の中に`index.html.erb`というファイルを作成します。

コントローラに関してはターミナルからコマンドで作成しましたが、ビューはテキストエディタから直接ファイルを作成しましょう。`users`ディレクトリで右クリックし、`New File(テキストエディタによって表示が異なる)`を選択してファイルを作成し、`名前をつけて保存`で`index.html.erb`と入力して保存をしましょう。

```
index.html.erb
```

上の記述の中で、`.html.erb`の部分は拡張子 となります。これはRails特有の拡張子で、`erb`は`embedded ruby`という意味になるます。`embedded`という単語が「埋め込まれた」という意味なので、「HTMLの中にrubyを埋め込むことができる」ということになります。

では、さっそく作成したビューファイルにHTMLの`h1`タグで`Hello World`を表示するコードを書いてみましょう。

```
<h1>Hello World!!</h1>
```

HTMLを書いたら、ターミナルからサーバーを立ち上げ、実際に画面に`Hello World!!`が表示されるか確かめます。サーバーを立ち上げるには、以下のコマンドを実行します。

```
rails s
```

コマンドを実行したら、以下のURLにアクセスしましょう。`Hello World!!`が表示されていれば成功です。

[http://localhost:3000/users](http://localhost:3000/users)


# 最後に
これで今回作成するアプリが完成したわけですが、最後にもう一つ、Railsを理解する上で重要な部分をご説明します。実は、Railsでは`views/layouts`の中に`application.html.erb`というファイルがあり、それがWeb上に画面を表示する際のテンプレートとなっています。`application.html.erb`は、アプリを作成した直後は以下のような状態になっています。

```
<!DOCTYPE html>
<html>
<head>
  <title>ControllerTest</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
</head>
<body>

<%= yield %>

</body>
</html>
```

この`application.html.erb`のコードの中で注目していただきたいのが、`<%= yield %>`の部分です。実は、先ほど`Hello World!!`を表示した際、この`<%= yield %>`の部分が`index.html.erb`の内容と置き換わって表示されていたのです。つまり、イメージとしては以下のようになります。

```
<!DOCTYPE html>
<html>
<head>
  <title>ControllerTest</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
</head>
<body>

<!-- yieldがindex.html.erbの内容と置き換わる -->
<h1>Hello World!!</h1>

</body>
</html>
```

以上をまとめると、以下のような流れでユーザーのリクエストが処理されます。

1. ユーザーがリクエストを送信する（URLにアクセス）
2. ルートによりURLに対応するコントローラのアクションに処理が移る
3. コントローラのアクションに対応するビューが表示される
 - ただし対応するビューが直接表示されるのではなく`layout`の`yield`がユーザーのリクエストに対応したビューと置き換わる

最初は混乱するかも知れませんが、ルート・コントローラ・ビューの実装を繰り返したり、サンプルコードをもとに自分なりにカスタマイズしてコードを書いていくうちに理解できるようになっていきます。ためしに、`index.html.erb`とは別に、`new.html.erb`を作成し、そのビューファイルが表示されるようにルート・コントローラ・ビューを編集して見ましょう。

# 練習問題
以下の問題を一つ一つ解いてみてください。

```
usersコントローラのnewアクションに処理が遷移するルートを定義してください。
```

```
usersコントローラにnewアクションを追加してください。
```

```
newアクションに対応するviewファイルを作成し、「Good morning!!」が表示されるようにしてください。
```",2018-11-07 04:55:24 UTC,2018-11-09 09:57:45 UTC
25,Ruby on Rails,Ruby on Rails アプリのデプロイ,"# Herokuに登録
まずは、Herokuにアカウントを作りましょう。

アカウントを作ったら、以下のページからカード情報を登録しましょう。（無断で課金されることはありません）

[Heroku カード追加ページ](https://dashboard.heroku.com/account/billing)

# Heroku CLI のインストール

```
brew install heroku/brew/heroku
```

# アプリを作成

Hello World

# デプロイ

```
gem 'sqlite3', group: :development
gem 'pg', group: :production
```

```
bundle install
```

`config/database.yml`を書き換え

```
production:
  <<: *default
  adapter: postgresql
  encoding: unicode
  pool: 5
```

```
heroku create
```

```
git init
```

```
git add .
```

```
git commit -m ""commit message""
```

```
git push heroku master
```

```
heroku run rake db:migrate
```

```
heroku run rake db:seed
```

```
heroku open
```

# アプリを変更したら
その場合は以下の手順でHerokuの更新を行ってください。

```
git add .
```

```
git commit -m ""commit message""
```

```
git push heroku master
```",2018-11-07 04:56:01 UTC,2018-11-07 04:56:01 UTC
26,Ruby on Rails,CRUD処理の実装,"# RESTについて
REST（Representational State Transfer）とは「ネットワーク上に置かれたリソース（データ）に対して表示、作成、更新、削除などの操作を行う」というアプリケーション作成における考え方です。

こちらは、Ruby on RailsでデータのCRUD処理（新規登録、一覧表示、更新、削除）を実装するにあたり、最初のうちから理解しておいた方がいいです。
ただ、一度に理解するのは難しいので、折をみて何度も繰り返し復習してみてください。

RESTは、Ruby on Railsアプリケーションを作成する上では重要な概念です。
この概念によって、効率よくデータベース上のデータを扱うことができます。

## RESTを意識したアプリケーションを作成するには
Ruby on RailsにおけるREST機能の中心を担うのがルーティングです。
Railsには、RESTに基づいたやり方でウェブアプリケーションを作成する機能があり、それにのっとって作成されたアプリを「RESTフル」といいます。

RESTの機能を利用すれば、Ruby on Railsの原則である「Don't Repeat Yourself（同じことを二度書かない）」や、「設定より規約（自由さよりもルール）」という考えを忠実に守ることができ、アプリケーションの開発や保守がより簡単になります。

Railsにおける「リソース」とは、コントローラが扱う対象となるデータのことです。
このリソースに対する、RESTフルなルーティングは以下の通りになります。

|HTTPメソッド|パス|コントローラのアクション|
|---|---|---|
|GET|/users|index|
|GET|/users/new|new|
|POST|/users|create|
|GET|/users/:id|show|
|GET|/users/:id/edit|edit|
|PATCH|/users/:id|update|
|DELETE|/users/:id|destroy|

上記の表において、`:id`の部分には任意の数字が入ります。
今はまだ用途がわからなくてもいいので、`:id`は整数を格納する変数のようなものだと理解しておきましょう。

この`:id`という記述によって、特定のデータを指定してデータの更新や削除を行うことができます。

# アプリの立ち上げ
今回、アプリを立ち上げる際は以下のコマンドを実行してください。

```
rails new crud_sample
```

## リソースを扱うコントローラ
コントローラでは、リソースベースのルーティングに従い決まった名前のアクションを7つ定義します。
このアクションに関しては、名前ごとに役割が決められているため、そのルールにしたがって実装すれば開発効率を向上させることができます。

以下の表には、RESTフルを実現させるために必要なアクション名とその役割をまとめておきます。

|アクション名|役割|対応するルーティング|
|---|---|---|
|index|リソースの一覧表示（テーブルのレコードを一覧表示）|/users|
|new|リソースを追加するためのフォームを表示する（新規作成画面を表示する）|/users/new|
|create|リソースを作成する（テーブルにレコードを追加する）|/users|
|show|リソースの詳細を表示する（レコードの詳細を表示する）|/users/:id|
|edit|リソースの更新画面を表示する（既存のレコードのカラムを更新するための画面）|/users/:id/edit|
|update|リソースを更新する（既存のレコードのカラムを更新する）|/users/:id|
|destroy|リソースを削除する（テーブルからレコードを削除する）|/users/:id|

コントローラにアクションを追加するときは、基本的に上の表にあるアクションを追加していきます。
実際にコードを書く際は、それぞれのアクションの役割をきちんと意識して使い分けられるようにしましょう。

ではさっそく、これからCRUD処理（新規登録、一覧表示、更新、削除）の実装をしていきましょう。
これが出来れば、晴れて初心者は卒業です。
何度も何度も繰り返して、体で覚えていきましょう。

# 新規投稿機能の実装
新規投稿機能を実装するためには、まず最初にデータベースが必要になります。
なので、以下のコマンドを実行してデータベースを作成しましょう。

```
bundle exec rake db:create
```

データベースが作成できたら、次にルーティングを設定します。
以下のコードを`config`ディレクトリ配下の`routes.rb`に記述しましょう。

```ruby
Rails.application.routes.draw do
  # 以下のルーティングを定義
  get '/users/new', to: 'users#new'
end
```

次にコントローラを作成します。
今回はユーザーのデータを扱うアプリを作成するので、`users`というコントローラを作成しましょう。
ターミナルから以下のコマンドを実行してください。

```
rails g controller users
```

無事に`users`コントローラが作成できたら、`app/controllers`の中にある`users_controller`を編集しましょう。

次は`new`アクションを定義します。
`users`コントローラに以下のコードを記述しましょう。

```ruby
class UsersController < ApplicationController
  # 以下のアクションを追加
  def new
    @user = User.new
  end
end
```

`users`コントローラに`new`アクションが作成できたら、`views/users`ディレクトリに`new.html.erb`を作成し、以下のコードを記述しましょう。
こちらが、投稿画面のフォームになります。

```
<%= form_for @user, url: ""/users"" , html: { method: :post } do |f| %>
  <p>投稿する</p>
  <p>お名前：<%= f.text_field :name %></p>
  <p>年齢：<%= f.text_field :age %></p>
  <%= f.submit %>
<% end %>
```

このフォームでは、`form_for`というヘルパーメソッドを使用しています。
Ruby on Railsには、基本的なフォームとして以下の2つがよく利用されています。

1. form_for
2. form_tag

この2つのフォームの使い分けは以下の通りです。

|フォーム名|用途|
|---|---|
|form_for|モデルに紐づいたフォームを作るときに使用する|
|form_tag|モデルに紐づかないフォームを作るときに使用する|

現場では、`form_for`の方が圧倒的に使用頻度が高いです。
実際、CRUD処理を実装するときは確実に`form_for`を利用すると考えてもいいくらい。

なぜ、モデルに紐づいたときに`form_for`を用いるのかというと、記述が圧倒的に楽になるからです。
今回はわかりやすいように、URLの部分を以下のように記載しました。

```
<%= form_for @user, url: ""/users"" , html: { method: :post } do |f| %>
```

しかし、実際は以下のように記述することもできるのです。

```
<%= form_for @user do |f| %>
```

`form_for`は紐づけられたモデルオブジェクト（今回なら`@user`）がすでにテーブルに存在しているのかどうかを判定してくれます。

もし、テーブルに同一データが存在してなければ`create`アクションに、存在していれば`update`アクションに、それぞれ自動的にルーティングを指定してくれるわけです。

以上の理由から、投稿フォームを作るなら`form_for`を利用して作成した方がいいです。
それに慣れれば、`form_tag`は簡単に扱えるようになります。

では、投稿画面が作成できたら、実際にデータを登録するテーブルとそれに関連するモデルを作成しましょう。
まずは以下のコマンドを実行し、`user`モデルを作成しましょう。

```
rails g model user
```

`rails g model`コマンドを実行すると、同時にマイグレーションファイルも作成されます。
このファイルは、データベースにどのような構造のテーブルを作成するかを指定することができます。
今回は、ユーザーの名前と年齢を登録できるテーブルを作成したいので、`name`と`age`のカラムが作成されるよう以下のコードを書きましょう。

```ruby
class CreateUsers < ActiveRecord::Migration[5.2]
  def change
    create_table :users do |t|
      t.string        :name
      t.integer       :age
      t.timestamps
    end
  end
end
```

ちなみに、マイグレーションファイルで指定できる型には以下のようなものがあります。
必要に応じて、指定する型を変えてください。

|データ方|説明|
|---|---|
|string|文字列|
|text|長い文字列|
|integer|整数|
|float|浮動小数|
|decimal|精度の高い小数|
|datetime|日時|
|timestamp|より細かい日時|
|time|時間|
|date|日付|
|binary|バイナリデータ|
|boolean|Boolean型|

マイグレーションファイルは中身を変更するだけではダメです。
以下のコマンドを実行し、マイグレーションファイルの内容をデータベースに反映させましょう。

```
bundle exec rake db:migrate
```

そうすると、アプリに紐づいたデータベースの中に、`users`テーブルが作成されます。

テーブルが作成できたら、次にデータベースにデータを登録するためのルーティングやコントローラの処理を実装していきます。

まずは、ルーティングから設定しましょう。

`config`  の中にある、 `routes.rb`を編集します。
新たなルーティングとして、`post`メソッドで`users`コントローラの`create`アクションを指定しましょう。

```ruby
Rails.application.routes.draw do
  get '/users/new', to: 'users#new'
  # 以下のルーティングを追加
  post '/users', to: 'users#create'
end
```

ルーティングが指定できたら、次にコントローラのアクションでデータを登録するための処理を書いていきます。
`app/controllers`の中にある `users_controller.rb` を開いてください。

## Strong Parameter
Railsでは、データベースに予期せぬ値が登録されないように、登録する値を制限できる機能があります。
それにより、「数字を登録するはずのところに文字列が登録される」といった不測の自体を防いでくれます。
そして、その機能を実現するのが`Strong Parameter`です。ではさっそく、その機能を実装していきましょう。

まずは、`users`コントローラに`create`アクションを追加します。

```ruby
class UsersController < ApplicationController

  def new
    @user = User.new
  end

  # 以下のアクションを追加
  def create
    # Strong Parameter の記述
    User.create(user_params)
  end

end
```

`create`アクションが追加できたら、同じ`users`コントローラ内に以下のコードを追記します。
こちらが、データベースに登録するデータを制限するための`Strong Parameter`の記述になります。

```ruby
class UsersController < ApplicationController

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のメソッドを追加
  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

この記述により、 `user` のパラメータに紐づいた `name` や `age` しかデータベースに登録できないようになります。

 ![strong_parameter](images/crud/strong_parameter.png)

なぜ `user` に紐づいた `name` や `age` がパラメータとしてコントローラで取得できるのかというと、 `form_for` の部分で `User` モデルに対するフォームを作成しているからです。

そのため、 `User` モデルを格納した `@user` を用いて  `form_for @user` と記述すると、送信ボタンを押したときには `user` に紐づいたパラメータが送信されます。



`create`アクションが追加できたら、`views/users`ディレクトリに`create.html.erb`を追加します。
追加が終わったら、`create.html.erb`に以下のコードを記述しましょう。

```
<h1>登録完了</h1>
<%= link_to ""一覧画面へ"", ""/users"" %>
```

ここまできたら、データベースにデータが登録できたか確認してみてください。
自分が投稿したデータがテーブルに保存されていれば、投稿機能の実装は成功です。

まずは、サーバーを立ち上げましょう。

```
rails s
```

サーバーが立ち上げられたら、以下のURLにアクセスしてください。

[http://localhost:3000/users/new](http://localhost:3000/users/new)

# 一覧表示機能の実装
新規投稿機能が実装できたら、次は投稿を一覧表示するための機能を作成します。
といっても、実装は簡単なのでサクッと終わらせちゃいましょう！

まずは、一覧表示画面へのルートを作成します。

```ruby
Rails.application.routes.draw do
  # 以下のルーティングを追加
  get '/users', to: 'users#index' 
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'
end
```

ルートが作成できたら、投稿したデータをデータベースから取り出す処理を書きます。
`users`コントローラに`index`アクションを定義し、以下のコードを書きましょう。

```ruby
class UsersController < ApplicationController
  # 以下のアクションを追加
  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`views/users`ディレクトリに`index.html.erb`を作成し、そこに以下のコードを記述しましょう。
これで、ユーザーデータが一覧表示できるようになります。

```
<%= link_to ""投稿画面へ"", ""/users/new"" %>
<% @users.each do |user| %>
  <p>
    <%= user.name %>
    <%= user.age %>
  </p>
<% end %>
```

ここまでできたら、一度サーバーを立ち上げRailsアプリの動作を確認してみましょう。
ユーザーのデータが一覧表示されていれば大丈夫です。
以下のURLでアクセスしてみてください。

[http://localhost:3000/users](http://localhost:3000/users)

# 削除機能の実装
データが一覧表示できたら、つぎにデータの削除機能を実装しましょう。
まずは、削除ボタンを作成します。

```
<% @users.each do |user| %>
  <p>
    <%= user.name %>
    <%= user.age %>
    <%= link_to '削除', ""/users/#{user.id}"", method: :delete, data: {confirm: ""削除しますか?""}  %>
  </p>
<% end %>
```

次に削除ボタンを押した時のルートを決めます。
以下のコードを`config/routes.rb`に追記しましょう。
すでに設定しているルートの下に書いて大丈夫です。

```ruby
Rails.application.routes.draw do
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'
  # 以下のルーティグを追記
  delete '/users/:id', to: 'users#destroy'
end
```

ここで`delete`などのメソッドの使い分けを確認！
ただページを遷移するだけなら`get`を使用しますが、それ以外は行いたい処理に合わせてHTTPメソッドを変更する必要があります。
ここで一通り、どんなHTTPメソッドがあるか確認しておきましょう。

|HTTPメソッド|用途|パス|コントローラ#アクション|
|---|---|---|---|
|GET|一覧表示|/users|users#index|
|GET|データ登録画面|/users/new|users#new|
|POST|データ登録|/users|users#create|
|DELETE|データ削除|/users/:id|users#destroy|
|PATCH/PUT|データ更新|/users/:id|users#update|

ルートが設定できたら、次は該当するユーザーのデータを削除する処理をコントローラに書きましょう。
その際使用するのは`destroy`というメソッドです。
`users`コントローラのアクションは`delete`ですが、実際に使用するメソッドは`destroy`であることに注意しましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  def destroy
    user = User.find(params[:id])
    user.delete
  end 

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

上のコードに関して、 `destroy` アクションでインスタンス変数（ `@user` など@マークのついた変数）を使用しない理由は、ビューにデータを受け渡す必要はないからです。

`delete` メソッドでは、ユーザーの情報を消すだけです。
なので、ビューにデータを受け渡す必要はなく、そのためインスタンス変数を使用せず、 `user` に対して `delete` メソッドを実行しています。。

アクションが追加できたら、 `views/users` ディレクトリにある `destroy.html.erb` に以下のコードを追加します。

```
<h1>削除完了</h1>
<%= link_to ""一覧画面へ"", ""/users"" %>
```

以上で削除機能の実装は完了です。
データが削除できるか確認したら、次は編集機能の実装に移りましょう。

# 編集機能を実装
編集機能を実装する際も、基本的には `delete` と感覚は同じです。
該当するユーザーデータの`id`パラメータを飛ばし、それをコントローラで受け取って`update`メソッドを実行するだけ！
それでは、学んでいきましょう。

編集画面へ遷移するためのボタンを一覧表示画面に作成します。
 `views/users` ディレクトリにある `index.html.erb` に以下のコードを追記しましょう。

```
<%= link_to ""投稿画面へ"", ""/users/new"" %>
<% @users.each do |user| %>
  <p>
    <%= user.name %><%= user.age %>
    <%= link_to '削除', ""/users/#{user.id}"", method: :delete, data: {confirm: ""削除しますか?""}  %>
    <%= link_to '編集', ""/users/#{user.id}/edit"", method: :get %> 
  </p>
<% end %>
```

リンクが作成できたら、編集画面へ遷移するためのルートを設定します。

```ruby
Rails.application.routes.draw do
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'

  # 以下のルーティングを追加
  get '/users/:id/edit', to: 'users#edit'

  delete '/users/:id', to: 'users#destroy'
end
```

ルーティングが設定できたら、 `users` コントローラに `edit` アクションを定義し、編集対象となるユーザーのデータを取得するための処理を書きましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  def edit
    @user = User.find(params[:id])
  end

  def destroy
    user = User.find(params[:id])
    user.delete
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`edit` アクションが追加できたら、 `views/users` ディレクトリに `edit.html.erb` を作成し、以下のコードを記述しましょう。

```
<%= form_for @user, url: ""/users/#{@user.id}"", html: { method: :patch } do |f| %>
  <p>更新</p>
  <p><%= f.text_field :name %></p>
  <p><%= f.text_field :age %></p>
  <input type=""submit"" value=""送信"">
<% end %>
```

編集完了画面へのルーティング

```ruby
Rails.application.routes.draw do
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'
  get '/users/:id/edit', to: 'users#edit'

  # 以下のルーティングを追加
  patch '/users/:id', to: 'users#update'

  delete '/users/:id', to: 'users#destroy'
end
```

ルーティングが設定できたら、 `users` コントローラにデータを更新するための `update` アクションを追加

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  def edit
    @user = User.find(params[:id])
  end

  # 以下のアクションを追加
  def update
    user = User.find(params[:id])
    user.update(user_params)
  end

  def destroy
    user = User.find(params[:id])
    user.delete
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

アクションが追加できたら `view/users` ディレクトリに `update.html.erb` を作成し、以下のコードを記述しましょう。

```
<h1>更新完了</h1>
<%= link_to ""一覧画面へ"", ""/users"" %>
```

これで編集機能の実装が完了しました。ユーザーのデータがきちんと更新できるか確認してみましょう。更新が確認できたらCRUD処理の実装は一通り終了です。
お疲れ様でした。

## おまけ
CRUD処理は実装できたのですが、コントローラの記述でもう少し改善できるところがあります。それが、 `create` `update` `destroy` の部分です。

これらのアクションに対応するビューは特に表示しなくても問題ないので、処理をした後すぐに一覧表示画面に遷移するようにしても問題ありません。

アクションの中で特定の処理をした後、他のアクションに処理を渡すためには `redirect_to` を使用します。以下のように、コントローラを編集してみましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
    # 以下のメソッドを追加
    redirect_to :action => ""index""
  end

  def edit
    @user = User.find(params[:id])
  end

  def update
    user = User.find(params[:id])
    user.update(user_params)
    # 以下のメソッドを追加
    redirect_to :action => ""index""
  end

  def destroy
    user = User.find(params[:id])
    user.delete
    # 以下のメソッドを追加
    redirect_to :action => ""index""
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

以上のように編集することで、 `create` `update` `destroy` の処理を行った後に、すぐに `index` に処理が渡されるようになりました。

試しに、データを新規作成し、データを投稿した後すぐに一覧表示画面に遷移するか確かめてみてください。確認できたら、実装は完了です。


# まとめ
このCRUD処理に関しては、現場でプログラマーとして働くためのボーダーラインと言われています。ということは、この処理をしっかり実装できるようになるだけで、現場で働くための最低限のスキルが身についたということになります。

この流れはとても大切なので、何度も繰り返し実装してみてください。

また、RESTフルなアプリケーションとはなんなのかを改めて確認しておきましょう。

![rest2](images/crud/rest2.png)



お疲れ様でした！

[ソースコードを確認する](https://github.com/yoshitokamizato/crud_sample2.git)",2018-11-07 04:56:49 UTC,2018-12-08 00:17:45 UTC
27,Ruby on Rails,Active Recordの様々なメソッド,"# Active Recordとは
Active Recordとは、直接SQLを記述することなくデータベースに存在するデータを扱えるようにする Ruby on Railsの機能です。
このActrive Recordのおかげで、プログラマーはSQL文を記述することなく、簡単なメソッドのみでデータの操作を行うことができます。

# データ検索に関するメソッド一覧
データベースからデータを検索するActrive Recordのメソッドはたくさんあります。
よく利用するものから順に書いていきますので、上の方から優先して学んでみてください。

- all
- find
- find_by
- first
- where
- pluck
- order
- distinct
- select
- group
- joins
- having

# all
テーブルの全てのレコードを検索する

```ruby
User.all
```

# find
`id`などの主キーが一致するレコードを取得します。

```ruby
user = User.find(1)
```

# find_by
指定したカラムで条件が一致する最初の1件のレコードを取得します。

```ruby
user = User.find_by(name: 'tanaka')
```

# first
レコードの最初の1件を取得します。

```ruby
user = User.first
```

# where
条件が一致するすべてのレコードを取得します。

```ruby
# 名前がsuzukiのユーザーを検索する
User.where(name: 'suzuki')
```

# where().first
条件が一致するレコードの最初の一件を取得します。

```ruby
user = User.where(name: 'tanaka').first
```

# pluck
特定のカラムで配列を作成する

```ruby
users_name = User.pluck(:name)
```

# order
取得したレコードを特定のカラムを基準に並べ換える

```ruby
# usersテーブルのレコードを降順で並び替えて取得する
user = User.order('id DESC')
```

# delete_all
テーブルのすべてのデータを削除する

```ruby
User.delete_all
```

# eager_load
テーブルを外部結合して全てのデータを取得する

```ruby
User.eager_load(:items)
```",2018-11-07 04:58:11 UTC,2018-11-07 04:58:11 UTC
28,Ruby on Rails,Active Record の様々な削除メソッド,"# 様々な削除メソッド
Railsには、様々な種類のデータ削除メソッドが用意されています。
ぜひ、それぞれのメソッドの種類を把握し、使いこなせるようにしてみてください。

各メソッドを試したい場合は`rails c`を使用し、モデルオブジェクトに対してメソッドを実行すると、簡単にテストを行うことができて便利です。

# destroy
`destroy`は、データを1件削除し、アソシエーションで関連付けたデータも自動的に削除します。

```ruby
User.find(1).destroy
```

# destroy_all
`destroy_all`は、複数のデータを削除し、アソシエーションで関連付けたデータも自動的に削除します。

```ruby
# idが20~26の間のデータを削除
# 関連データも削除
User.where(id: 20..26).destroy_all
```

# delete
`delete`は、データを1件削除します。その際、関連するデータは削除されません。

```ruby
User.find(4).delete
```

# delete_all
`delete_all`は、複数のデータを削除します。その際、関連するデータは削除されません。

```ruby
# idが1~10の間のデータを削除
User.where(id: 1..10).delete_all
```

# まとめ
`destroy`は関連付けされたデータも一気に消すことができますが、影響範囲が大きいので、使用する際は注意しましょう。

それぞれのメソッドの微妙な違いを把握し、使いこなせるようにしておくと処理の幅が広がります。",2018-11-07 04:58:55 UTC,2018-11-07 04:58:55 UTC
29,Ruby on Rails,resources を使ったCRUD処理の実装,"# はじめに
今回は、URLを直書きせず名前付きルートを使用したCRUD処理の実装について解説していきます。現場では、今回ご紹介するやり方が一般的なので、CRUD処理の基本を理解できたらぜひ挑戦してみてください。

# resources
`resources`とは、`index, new, create, show, edit, update, delstroy`などのルーティングを一括で定義することができるとても便利なメソッドです。これにより、簡単にRESTフルなRailsアプリを作成することができます。

# 新規投稿機能の実装
新規投稿機能を実装するためには、まず最初にデータベースが必要になります。なので、以下のコマンドを実行してデータベースを作成しましょう。

```
bundle exec rake db:create
```

次にルーティングを設定します。以下のコードを`config`ディレクトリ配下の`routes.rb`に記述しましょう。

```ruby
Rails.application.routes.draw do
  # 以下のルーティングを定義
  resources :users
end
```

次にコントローラを作成します。今回はユーザーのデータを扱うアプリを作成するので、`users`というコントローラを作成しましょう。

```
rails g controller users
```

コントローラが作成できたら、`new`アクションを定義します。`users`コントローラに以下のコードを記述しましょう。

```ruby
class UsersController < ApplicationController
  # 以下のアクションを追加
  def new
    @user = User.new
  end
end
```

`users`コントローラに`new`アクションが作成できたら、`views/users`ディレクトリに`new.html.erb`を作成し、以下のコードを記述しましょう。こちらが、投稿画面のフォームになります。

```
<%= form_for @user, url: users_path, html: { method: :post } do |f| %>
  <p>新規登録</p>
  <p>お名前：<%= f.text_field :name %></p>
  <p>年齢：<%= f.text_field :age %></p>
  <input type=""submit"" value=""送信"" >
<% end %>
```

投稿画面が作成できたら、実際にデータを登録するテーブルとそれに関連するモデルを作成します。まずは以下のコマンドを実行し、`user`モデルを作成しましょう。

```
rails g model user
```


`rails g model`コマンドを実行すると、同時にマイグレーションファイルも作成されます。このファイルは、データベースにどのような構造のテーブルを作成するかを指定することができます。今回は、ユーザーの名前と年齢を登録できるテーブルを作成したいので、`name`と`age`のカラムが作成されるよう以下のコードを書きましょう。

```ruby
class CreateUsers < ActiveRecord::Migration[5.2]
  def change
    create_table :users do |t|
      t.string        :name
      t.integer       :age
      t.timestamps
    end
  end
end
```

ちなみに、マイグレーションファイルで指定できる型には以下のようなものがあります。必要に応じて、指定する型を変えてください。

|データ方|説明|
|---|---|
|string|文字列|
|text|長い文字列|
|integer|整数|
|float|浮動小数|
|decimal|精度の高い小数|
|datetime|日時|
|timestamp|より細かい日時|
|time|時間|
|date|日付|
|binary|バイナリデータ|
|boolean|Boolean型|

マイグレーションファイルは中身を変更するだけではダメです。以下のコマンドを実行し、マイグレーションファイルの内容をデータベースに反映させましょう。

```
bundle exec rake db:migrate
```

マイグレーションファイルを実行できたら、`users`コントローラに`create`アクションを追加します。

```ruby
class UsersController < ApplicationController

  def new
    @user = User.new
  end

  # 以下のアクションを追加
  def create
    # Strong Parameter の記述
    User.create(user_params)
  end

end
```

`create`アクションが追加できたら、同じ`users`コントローラ内に以下のコードを追記します。こちらが、データベースに登録するデータを制限するための`Strong Parameter`の記述になります。

```ruby
class UsersController < ApplicationController

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`create`アクションが追加できたら、`views/users`ディレクトリに`create.html.erb`を追加します。追加が終わったら、`create.html.erb`に以下のコードを記述しましょう。

```
<h1>登録完了</h1>
<%= link_to ""一覧画面へ"", users_path %>
```

ここまできたら、データベースにデータが登録できたか確認してみてください。自分が投稿したデータがテーブルに保存されていれば、投稿機能の実装は成功です。

# 一覧表示機能の実装
新規投稿機能が実装できたら、次は投稿を一覧表示するための機能を作成します。

ルートが作成できたら、投稿したデータをデータベースから取り出す処理を書きます。`users`コントローラに`index`アクションを定義し、以下のコードを書きましょう。

```ruby
class UsersController < ApplicationController
  # 以下のアクションを追加
  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`views/users`ディレクトリに`index.html.erb`を作成し、そこに以下のコードを記述しましょう。これで、ユーザーデータが一覧表示できるようになります。

```
<%= link_to ""投稿画面へ"", new_user_path %>
<% @users.each do |user| %>
  <p>
    <!-- 以下の2行のコードを追加 -->
    <%= user.name %>
    <%= user.age %>
  </p>
<% end %>
```

ここまでできたら、一度サーバーを立ち上げRailsアプリの動作を確認してみましょう。ユーザーのデータが一覧表示されていれば大丈夫です。以下のURLでアクセスしてみてください。

# 削除機能の実装
データが一覧表示できたら、つぎにデータの削除機能を実装しましょう。まずは、`views/users`ディレクトリにある`index.html.erb`に削除ボタンを作成します。

```
<%= link_to ""投稿画面へ"", new_user_path %>
<% @users.each do |user| %>
  <p>
    <%= user.name %>
    <%= user.age %>
    <!-- 以下のコードを追加 -->
    <%= link_to ""削除"", user_path(user), method: :delete, data: {confirm: ""削除しますか?""} %>
  </p>
<% end %>
```

該当するユーザーのデータを削除する処理をコントローラに書きましょう。その際使用するのは`destroy`というメソッドです。`users`コントローラのアクションは`delete`ですが、実際に使用するメソッドは`destroy`であることに注意しましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  def destroy
    user = User.find(params[:id])
    user.destroy
  end 

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

アクションが追加できたら、`views/users`ディレクトリにある`destroy.html.erb`に以下のコードを追加します。

```
<h1>削除完了</h1>
<%= link_to ""一覧画面へ"", users_path %>
```

以上で削除機能の実装は完了です。データが削除できるか確認したら、次は編集機能の実装に移りましょう。

# 編集機能を実装
編集機能を実装する際も、基本的には`delete`と感覚は同じです。該当するユーザーデータの`id`パラメータを飛ばし、それをコントローラで受け取って`update`メソッドを実行するだけ！それでは、学んでいきましょう。

編集画面へ遷移するためのボタンを一覧表示画面に作成します。`views/users`ディレクトリにある`index.htmle.erb`に以下のコードを追記しましょう。

```
<%= link_to ""投稿画面へ"", new_user_path %>
<% @users.each do |user| %>
  <p>
    <%= user.name %>
    <%= user.age %>
    <%= link_to ""削除"", user_path(user), method: :delete, data: {confirm: ""削除しますか?""} %>
    <!-- 以下のコードを追加 -->
    <%= link_to ""編集"", edit_user_path(user), method: :get %>
  </p>
<% end %>
```

`index.html.erb`に追記ができたら、`users`コントローラに`edit`アクションを定義し、編集対象となるユーザーのデータを取得するための処理を書きましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  def edit
    @user = User.find(params[:id])
  end

  def destroy
    user = User.find(params[:id])
    user.destroy
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`edit`アクションが追加できたら、`views/users`ディレクトリに`edit.html.erb`を作成し、以下のコードを記述しましょう。

```
<%= form_for @user, url: user_path(@user), html: { method: :patch } do |f| %>
  <p>更新</p>
  <p>お名前：<%= f.text_field :name %></p>
  <p>年齢：<%= f.text_field :age %></p>
  <input type=""submit"" value=""送信"" >
<% end %>
```

`edit.html.erb`に記述ができたら、`users`コントローラにデータを更新するための`update`アクションを追加

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  def edit
    @user = User.find(params[:id])
  end

  # 以下のアクションを追加
  def update
    user = User.find(params[:id])
    user.update(user_params)
  end

  def destroy
    user = User.find(params[:id])
    user.destroy
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

アクションが追加できたら`view/users`ディレクトリに`update.html.erb`を作成し、以下のコードを記述しましょう。

```
<h1>更新完了</h1>
<%= link_to ""一覧画面へ"", users_path %>
```

これで編集機能の実装が完了しました。ユーザーのデータがきちんと更新できるか確認してみましょう。更新が確認できたらCRUD処理の実装は一通り終了です。お疲れ様でした。",2018-11-07 05:00:22 UTC,2018-11-12 09:07:56 UTC
30,Ruby on Rails,Rails Best Practice の導入,"# Rails Best Practice
`Rails Best Practice`とは、Railsで推奨されている開発手法に則ってコードが書かれているかを簡単にチェックできるgemです。

このgemを使用することにより、データベースの作成の仕方やコントローラの記述、不要なファイルの存在などをチェックし、改善点を指摘してもらえるようになります。

## インストール方法
以下のコードを`Gemfile`に記述します。

```ruby
gem 'rails_best_practices'
```

`Gemfile`を編集したら、以下のコマンドをターミナルから実行し、gemをインストールします。

```
bundle install
```

そうすると、通常の`bundle install`の時とは異なり、以下のような表示が最後に出ます。

```
*************************************************************************
*******

  rails_best_practices is a code metric tool to check the quality of rail
s codes.

  I highly recommend you browse the Rails Best Practices website first.

      http://rails-bestpractices.com


  Enjoy!

      Richard Huang (flyerhzm@gmail.com)

*************************************************************************
*******
```

ちょっとビビるかもしれませんが、これは`rails_best_practices`を導入することによる表示なので、気にしないでください。

## 使用方法
この`Rails Best Practice`を使用するときは、以下のコマンドをターミナルから実行します。

Railsアプリ全体のチェックをする場合

```
bundle exec rails_best_practices .
```

特定のファイルのチェックをする場合（例：htmlに対してチェックを行う場合）

```
bundle exec rails_best_practices -f html .
```

特定のファイルを除外してチェックする場合（`e`は`exclude：除外`という意味）

```
bundle exec rails_best_practices -e ""db/migrate"" .
```

複数のディレクトリを除外する場合

```
bundle exec rails_best_practices -e ""db/migrate,vendor"" .
```

## 実行結果
僕の作ったアプリで、実際に`bundle exec rails_best_practices .`を実行してみると、以下のような結果が出ました。

```
/Users/yoshito/rails_lesson/login_sample4/db/schema.rb:15 - always add db
 index (items => [user_id])
/Users/yoshito/rails_lesson/login_sample4/app/views/items/index.html.erb:
4 - law of demeter
/Users/yoshito/rails_lesson/login_sample4/app/views/items/index.html.erb:
4 - law of demeter
/Users/yoshito/rails_lesson/login_sample4/app/helpers/items_helper.rb:1 -
 remove empty helpers
/Users/yoshito/rails_lesson/login_sample4/app/helpers/users_helper.rb:1 -
 remove empty helpers
 /Users/yoshito/rails_lesson/login_sample4/config/routes.rb:5 - restrict a
uto-generated routes items (only: [:new, :create, :index])
/Users/yoshito/rails_lesson/login_sample4/config/initializers/devise.rb:1

2 - remove trailing whitespace
```


１つ１つのメッセージを確認していきましょう。

### always add db index
こちらのメッセージは、ちゃんとインデックスをつけましょうという指摘です。

```
/Users/yoshito/rails_lesson/login_sample4/db/schema.rb:15 - always add db
 index (items => [user_id])
```

インデックスとは、データベースの検索を行いやすくするための索引のことですね。
それをマイグレーションファイルに記述してください、ということです。

このメッセージを解決するには、マイグレーションファイルに`add_index`のような記述をします。

```ruby
class CreateUsers < ActiveRecord::Migration[5.1]
  def change
    create_table :users do |t|
      t.string :name
      t.string :email      
      t.integer :age
      t.timestamps
    end
    # この記述
    add_index :users, :name
  end
end
```

### Law of Demeter
こちらのメッセージは、リレーションに関する指摘です。

```
/Users/yoshito/rails_lesson/login_sample4/app/views/items/index.html.erb:
4 - law of demeter
```

具体的には、「以下のようにデータを呼び出さないでね〜」ということです。

```
item.user.nickname
```

上のように`~.~.~`みたいに書くのではなく、`~.~`というふうに短く書くほうがスマートです。今回の場合だと、`item.user.nickname`ではなく`item.user_nickname`のように記述するということですね。

そのため、`item`モデルの記述を以下のように改善する必要があります。

`item`モデルの記述

```ruby
class Item
  # user_nicknameを定義
  def user_nickname
    user.nickname
  end
end
```

ビューの記述

```
item.user_nickname
```

### Remove Empty Helpers
こちらのメッセージは、不要な`helper`を削除してくださいということです。

```
/Users/yoshito/rails_lesson/login_sample4/app/helpers/users_helper.rb:1 -
 remove empty helpers
```

ちなみに、`helper`は`/app/helpers`の中にあります。
コマンドによっては、この`helper`が自動生成されるため、不要なファイルがいつの間にかできてしまいます。

使用していない`helper`に関しては、ソースコードを管理しやすくするためにも削除しておきましょう。

### Restrict auto-generated routes
こちらのメッセージは、「使用していないルーティングを省きましょう」という意味になります。

```
/Users/yoshito/rails_lesson/login_sample4/config/routes.rb:5 - restrict a
uto-generated routes items (only: [:new, :create, :index])
```

`resources`を使用している場合は自動でルーティングが設定されますが、アプリの構成によっては不要なルーティングが出てきます。

例えば、詳細ページ`new`や`create`、`index`しか使用していない場合、他のルーティングは不要になりますね。
その場合、いらないルーティングは使用しないように限定してあげたほうがいいです。

使用するルーティングを指定するには、以下のように記述します。

```ruby
resources :items, only: [:new, :create, :index]
```

# まとめ
Ruby on Railsを学ぶなら、この`Rails Best Practice`というgemを導入すると、学習効率が爆発的にアップします。
正しい記述を学ぶためにも、アプリを作成する際には毎回このgemを導入するようにしましょう。

それだけで、正しいRuby on Railsの使い方が身につくようになりますよ。

`Rails Best Practice`のメッセージを読むだけでもとても勉強になるので、ぜひ導入してみてください。",2018-11-07 05:01:15 UTC,2018-12-08 00:09:59 UTC
31,Ruby on Rails,Bootstrap の導入,"# Bootstrap
Bootstrapは、Twitter社が開発したフロントエンドのフレームワークです。Bootstrapを利用すると、CSSやJavaScriptを書かなくてもおしゃれでレスポンシブなデザインが実装できます。フロントエンドの開発効率が飛躍的に上がので、ぜひ利用してみてください。

## RailsアプリへのBootstrapの導入
今回のは、`Bootstrap4`をRailsアプリへ導入します。それでは、gemファイルに以下のコードを追記しましょう。Bootstrapは

```ruby
gem 'bootstrap', '~> 4.1.1'
gem 'jquery-rails'
```

Gemfileの編集が終わったらターミナルで`bundle install`を実行し、gemをインストールします。（アプリのディレクトリに移動してから実行してください）

```
bundle install
```

`/app/assets`にある`application.css`の拡張子を`scss`に変更します。ファイルを選択して右クリックし`rename`を選択して名前を変えましょう。

```
application.css => application.scss
```

`application.scss`に以下のコードを追記します。

```css
@import ""bootstrap"";
```

`applicaiton.js`に以下のコードを追記します。

```
//= require jquery3
//= require popper
//= require bootstrap-sprockets
```

レスポンシブに対応させるため、以下のコードを`/views/laouts`の中にある`application.html.erb`の`head`タグの中に記述します。

```html
<meta name=""viewport"" content=""width=device-width, initial-scale=1, shrink-to-fit=no"">
```

以下のコードを`application.html.erb`に記述し、Bootstrapが適用されているか確かめます。

```html
<button type=""button"" class=""btn btn-primary"" data-toggle=""tooltip"" data-placement=""top"" title=""Tooltip on top"">
	Tooltip on top
</button>
```

青色のボタンが表示されていれば、Bootstrapの実装は完了です。

# テーブルにフィルターを追加する
試しにBootstrapに機能を用いて、テーブルにフィルター機能をつけてみましょう。

この機能は、検索窓にキーワードを入力すると、その文字が含まれている行だけをテーブルに表示できるようにするものです。

まずは、以下のコードをテーブルを配置するページのHTMLの一番下に追記してください。

```
<script>
  $(document).ready(function(){
    $(""#myInput"").on(""keyup"", function() {
      var value = $(this).val().toLowerCase();
      $(""#myTable tr"").filter(function() {
        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
      });
    });
  });
</script>
```

次に、テーブルを作成します。その際、テーブルの上に検索窓を設置するようにしましょう。

また、テーブルに関してもBootstrapで用意されているものを使用します。

```html
<!-- フィルタリングを行うための検索窓 -->
<input class=""form-control"" id=""myInput"" type=""text"" placeholder=""Search Curriculum.."">

<!-- テーブル -->
<table class=""table table-striped"">
  <thead class=""bg-danger text-white"">
    <tr>
      <th>言語</th>
      <th>説明</th>
    </tr>
  </thead>
  <tbody id=""myTable"">
    <tr>
      <td>HTML/CSS</td>
      <td>Webサイトの画面を作るための言語</td>
    </tr>
    <tr>
      <td>Ruby</td>
      <td>Webサイトの裏側の処理をする言語</td>
    </tr>
    <tr>
      <td>Python</td>
      <td>人工知能を開発するための言語</td>
    </tr>
  </tbody>
</table>
```

これだけで準備は完了です。

あとは、画面を表示して検索窓に何かしらのキーワードを入力し、データがきちんとフィルタリングできるか確かめてみてください。

このように、Bootstrapは動的でおしゃれな実装が簡単にできます。

そのため、現場でも非常によく使用されるフロントエンドのフレームワークです。

Bootstrapには、他にもたくさん利用できるパーツがあるので、色々と試してみてください。


# Component
Bootstrapには、非常に多彩なコンポーネント（部品）が用意されています。その中でも、よく利用するものをご紹介します。

## Buttons
様々なサイズや色、アクションのボタンが用意されています。

基本的なボタン

```html
<button type=""button"" class=""btn btn-primary"">Primary</button>
<button type=""button"" class=""btn btn-secondary"">Secondary</button>
<button type=""button"" class=""btn btn-success"">Success</button>
<button type=""button"" class=""btn btn-danger"">Danger</button>
<button type=""button"" class=""btn btn-warning"">Warning</button>
<button type=""button"" class=""btn btn-info"">Info</button>
<button type=""button"" class=""btn btn-light"">Light</button>
<button type=""button"" class=""btn btn-dark"">Dark</button>

<button type=""button"" class=""btn btn-link"">Link</button>
```

ホバーエフェクトのあるボタン

```html
<button type=""button"" class=""btn btn-outline-primary"">Primary</button>
<button type=""button"" class=""btn btn-outline-secondary"">Secondary</button>
<button type=""button"" class=""btn btn-outline-success"">Success</button>
<button type=""button"" class=""btn btn-outline-danger"">Danger</button>
<button type=""button"" class=""btn btn-outline-warning"">Warning</button>
<button type=""button"" class=""btn btn-outline-info"">Info</button>
<button type=""button"" class=""btn btn-outline-light"">Light</button>
<button type=""button"" class=""btn btn-outline-dark"">Dark</button>
```

ラジオボタン

```html
<div class=""btn-group btn-group-toggle"" data-toggle=""buttons"">
  <label class=""btn btn-secondary active"">
    <input type=""radio"" name=""options"" id=""option1"" autocomplete=""off"" checked> Active
  </label>
  <label class=""btn btn-secondary"">
    <input type=""radio"" name=""options"" id=""option2"" autocomplete=""off""> Radio
  </label>
  <label class=""btn btn-secondary"">
    <input type=""radio"" name=""options"" id=""option3"" autocomplete=""off""> Radio
  </label>
</div>
```

## Navbar
Bootstrapを使用すれば、レスポンシブなナビゲーションバーもあっという間に作れます。

基本的なナビゲーションバー

```html
<nav class=""navbar navbar-expand-lg navbar-light bg-light"">
  <a class=""navbar-brand"" href=""#"">Navbar</a>
  <button class=""navbar-toggler"" type=""button"" data-toggle=""collapse"" data-target=""#navbarSupportedContent"" aria-controls=""navbarSupportedContent"" aria-expanded=""false"" aria-label=""Toggle navigation"">
    <span class=""navbar-toggler-icon""></span>
  </button>

  <div class=""collapse navbar-collapse"" id=""navbarSupportedContent"">
    <ul class=""navbar-nav mr-auto"">
      <li class=""nav-item active"">
        <a class=""nav-link"" href=""#"">Home <span class=""sr-only"">(current)</span></a>
      </li>
      <li class=""nav-item"">
        <a class=""nav-link"" href=""#"">Link</a>
      </li>
      <li class=""nav-item dropdown"">
        <a class=""nav-link dropdown-toggle"" href=""#"" id=""navbarDropdown"" role=""button"" data-toggle=""dropdown"" aria-haspopup=""true"" aria-expanded=""false"">
          Dropdown
        </a>
        <div class=""dropdown-menu"" aria-labelledby=""navbarDropdown"">
          <a class=""dropdown-item"" href=""#"">Action</a>
          <a class=""dropdown-item"" href=""#"">Another action</a>
          <div class=""dropdown-divider""></div>
          <a class=""dropdown-item"" href=""#"">Something else here</a>
        </div>
      </li>
      <li class=""nav-item"">
        <a class=""nav-link disabled"" href=""#"">Disabled</a>
      </li>
    </ul>
    <form class=""form-inline my-2 my-lg-0"">
      <input class=""form-control mr-sm-2"" type=""search"" placeholder=""Search"" aria-label=""Search"">
      <button class=""btn btn-outline-success my-2 my-sm-0"" type=""submit"">Search</button>
    </form>
  </div>
</nav>
```

色付きのナビゲーションバー

```html
<nav class=""navbar navbar-expand-lg navbar-light bg-light"">
  <a class=""navbar-brand"" href=""#"">Navbar w/ text</a>
  <button class=""navbar-toggler"" type=""button"" data-toggle=""collapse"" data-target=""#navbarText"" aria-controls=""navbarText"" aria-expanded=""false"" aria-label=""Toggle navigation"">
    <span class=""navbar-toggler-icon""></span>
  </button>
  <div class=""collapse navbar-collapse"" id=""navbarText"">
    <ul class=""navbar-nav mr-auto"">
      <li class=""nav-item active"">
        <a class=""nav-link"" href=""#"">Home <span class=""sr-only"">(current)</span></a>
      </li>
      <li class=""nav-item"">
        <a class=""nav-link"" href=""#"">Features</a>
      </li>
      <li class=""nav-item"">
        <a class=""nav-link"" href=""#"">Pricing</a>
      </li>
    </ul>
    <span class=""navbar-text"">
      Navbar text with an inline element
    </span>
  </div>
</nav>
```

トグルナビゲーションバー

```html
<div class=""pos-f-t"">
  <div class=""collapse"" id=""navbarToggleExternalContent"">
    <div class=""bg-dark p-4"">
      <h5 class=""text-white h4"">Collapsed content</h5>
      <span class=""text-muted"">Toggleable via the navbar brand.</span>
    </div>
  </div>
  <nav class=""navbar navbar-dark bg-dark"">
    <button class=""navbar-toggler"" type=""button"" data-toggle=""collapse"" data-target=""#navbarToggleExternalContent"" aria-controls=""navbarToggleExternalContent"" aria-expanded=""false"" aria-label=""Toggle navigation"">
      <span class=""navbar-toggler-icon""></span>
    </button>
  </nav>
</div>
```

## Tables
オシャレなテーブルを作成することができます。

```html
<table class=""table"">
  <thead>
    <tr>
      <th scope=""col"">#</th>
      <th scope=""col"">First</th>
      <th scope=""col"">Last</th>
      <th scope=""col"">Handle</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope=""row"">1</th>
      <td>Mark</td>
      <td>Otto</td>
      <td>@mdo</td>
    </tr>
    <tr>
      <th scope=""row"">2</th>
      <td>Jacob</td>
      <td>Thornton</td>
      <td>@fat</td>
    </tr>
    <tr>
      <th scope=""row"">3</th>
      <td>Larry</td>
      <td>the Bird</td>
      <td>@twitter</td>
    </tr>
  </tbody>
</table>
```

ダークな感じ

```html
<table class=""table table-dark"">
  <thead>
    <tr>
      <th scope=""col"">#</th>
      <th scope=""col"">First</th>
      <th scope=""col"">Last</th>
      <th scope=""col"">Handle</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope=""row"">1</th>
      <td>Mark</td>
      <td>Otto</td>
      <td>@mdo</td>
    </tr>
    <tr>
      <th scope=""row"">2</th>
      <td>Jacob</td>
      <td>Thornton</td>
      <td>@fat</td>
    </tr>
    <tr>
      <th scope=""row"">3</th>
      <td>Larry</td>
      <td>the Bird</td>
      <td>@twitter</td>
    </tr>
  </tbody>
</table>
```

ヘッダーの色を変える

```html
<table class=""table"">
  <thead class=""thead-dark"">
    <tr>
      <th scope=""col"">#</th>
      <th scope=""col"">First</th>
      <th scope=""col"">Last</th>
      <th scope=""col"">Handle</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope=""row"">1</th>
      <td>Mark</td>
      <td>Otto</td>
      <td>@mdo</td>
    </tr>
    <tr>
      <th scope=""row"">2</th>
      <td>Jacob</td>
      <td>Thornton</td>
      <td>@fat</td>
    </tr>
    <tr>
      <th scope=""row"">3</th>
      <td>Larry</td>
      <td>the Bird</td>
      <td>@twitter</td>
    </tr>
  </tbody>
</table>

<table class=""table"">
  <thead class=""thead-light"">
    <tr>
      <th scope=""col"">#</th>
      <th scope=""col"">First</th>
      <th scope=""col"">Last</th>
      <th scope=""col"">Handle</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope=""row"">1</th>
      <td>Mark</td>
      <td>Otto</td>
      <td>@mdo</td>
    </tr>
    <tr>
      <th scope=""row"">2</th>
      <td>Jacob</td>
      <td>Thornton</td>
      <td>@fat</td>
    </tr>
    <tr>
      <th scope=""row"">3</th>
      <td>Larry</td>
      <td>the Bird</td>
      <td>@twitter</td>
    </tr>
  </tbody>
</table>
```

## 公式サイト
こちらにサンプルがあるので参考にして実装していきましょう。

[Bootstrap公式サイト](https://getbootstrap.com/docs/4.1/components/alerts/)",2018-11-07 05:01:42 UTC,2018-11-19 03:06:42 UTC
32,Ruby on Rails,CSVデータインポート機能,"# CSVデータインポート
開発の現場では大量のデータを取り扱うため、ExcelでCSVデータを作成し、それをデータベースに一気に投入するという方法がよく使用されています。汎用性の高い技術なので、ぜひ自分で実装できるようにしましょう。

まず最初に、CSVデータ登録機能を実装するアプリを作成します。

```
rails new csv_data
```

僕はデータベースに`PostgreSQL`を使用しているので、以下のコマンドを実行してアプリを立ち上げました。

```
rails new csv_data -d postgresql
```

アプリが作成できたら、アプリのディレクトリに移動しましょう。

```
cd csv_data
```

移動ができたら、アプリに対応するデータベースを作成するため、以下のコマンドを実行しましょう。

```
bundel exec rake db:create
```

データを登録するテーブルを作成するため、以下のコマンドをターミナルから実行し、テーブルに対応する`user`モデルを作成します。

```
rails g model user
```

modelと同時に`db/migrate`配下に作成されたマイグレーションファイルを、以下のように編集しましょう。今回は、name,age,addressの３つカラムを作成し、データ投入を行います。そのため、nameをstring、ageをinteger、addressをstringで作成します。

```ruby
class CreateDataTests < ActiveRecord::Migration[5.2]
  def change
    create_table :users do |t|

      # 以下の3行を追加
      t.string :name
      t.integer :age
      t.string :address

      t.timestamps
    end
  end
end
```

マイグレーションファイルを実行し、データベースにテーブルを作成します。

```
bundle exec rake db:migrate
```

`app/models`の中にある`application_record.rb`に、CSVデータをインポートするためのコードを追記します。

```ruby
# この記述がないとNameError: uninitialized constant DataTest::CSVになる
require 'csv'
```

次に、データ投入のコードを記述するためのmodelを作成します。こちらは、`rails g model `コマンドを実行せず、直接`models`配下にファイルを作成しましょう。ファイル名は`import_csv.rb`です。

ファイルが作成できたら、以下のコードを記述します。

```ruby
class ImportCsv < ApplicationRecord
  # CSVデータのパスを引数として受け取り、インポート処理を実行
  def self.import(path)
     CSV.foreach(path, headers: true) do |row|
       User.create(
         name: row[""name""],
         age: row[""age""],
         address: row[""address""]
       )
     end
  end
end
```

それでは、上のコードの解説に入ります。

以下の部分はクラスメソッドと呼ばれるメソッドの定義の仕方です。

```ruby
def self.import
end
```

このようにメソッドを定義すると、`new`演算子を用いてモデルクラスのオブジェクトを生成する必要がなくなります。

```ruby
# 通常のメソッドを呼び出す方法
# new演算子でオブジェクト化する必要がある
import_csv = ImportCsv.new
import_csv.import

# クラスメソッドの場合
# new演算子がいらない
ImportCsv.import
```

次に、`path`の部分では`csv`ファイルが存在する場所を示すための文字列を格納しています。

実際は、以下のように書いてもインポート処理を実行することができます。

```ruby
# CSVデータファイルのある場所（パス）
path = 'db/csv_data/csv_data.csv'

# pathの情報をもとにCSVファイルのデータを読み込み
CSV.foreach(path, headers: true) do |row|
  User.create(
    name: row[""name""],
    age: row[""age""],
    address: row[""address""]
  )
end
```

そして、以下の部分でCSVファイルのヘッダー情報を読み取っています。

```ruby
headers: true
```

これがあることによって、以下のコードで対応する列のCSVデータの情報を読み取れるようになるわけです。

```ruby
CSV.foreach(path, headers: true) do |row|
  User.create(
    # row[""name""]でCSVデータのname列の情報を指定して読み込むことができる
    name: row[""name""],
    # row[""age""]でCSVデータのage列の情報を指定して読み込むことができる
    age: row[""age""],
    # row[""address""]でCSVデータのaddress列の情報を指定して読み込むことができる
    address: row[""address""]
  )
end
```

次に、CSVファイルを保管するための`csv_data`ディレクトリを`db`に作成しましょう。そして、その中に`csv_data.csv`という名前のCSVファイルを作成します。作成したCSVファイルには、以下の内容を記述しましょう。

```
name,age,address
tanaka,33,okinawa
saitou,32,fukuoka
yanagi,24,hokkaido
```

CSVデータの用意が終わったら、ターミナルで`rails c`コマンドを入力し、Rails環境のコンソールを立ち上げます。

```
rails c
```

コンソールが立ち上がったら、以下のコマンドを実行しましょう。

```ruby
ImportCsv.import('db/csv_data/csv_data.csv')
```

エラーが出なければ、処理は完了です。きちんとデータが登録されているか確認しましょう。`rails c`で立ち上げた画面から、以下のコードを実行します。

```
User.all
```

ユーザーのデータが表示されれば、インポートは成功です。

```
User Load (0.4ms)  SELECT  ""users"".* FROM ""users"" LIMIT $1  [[""LIMIT"", 11]]
=> #<ActiveRecord::Relation [#<User id: 1, name: ""hogehoge1"", age: 11, address: ""hogehoge1"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 2, name: ""hogehoge2"", age: 22, address: ""hogehoge2"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 3, name: ""hogehoge3"", age: 33, address: ""hogehoge3"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 4, name: ""hogehoge4"", age: 44, address: ""hogehoge4"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 5, name: ""hogehoge5"", age: 55, address: ""hogehoge5"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">]>
```

## もうちょっと改善！
ここまでの内容でも、データベースへのインポート機能は実装できたのですが、もうちょっと改善したコードについても学んでいきましょう。これで実装する際のバリエーションがちょっと増えます。

```ruby

class ImportCsv < ApplicationRecord
  # CSVデータのパスを引数として受け取り、インポート処理を実行
  def self.users_data
    # インポートするファイルのパスを取得
    path = File.join Rails.root, ""db/csv/csv_data.csv""
    # インポートするデータを格納するための配列
    list = []
    # CSVファイルからインポートするデータを取得し配列に格納
    CSV.foreach(path, headers: true) do |row|
      list << {
          name: row[""name""],
          age: row[""age""],
          address: row[""address""]
      }
    end
    puts ""インポート処理を開始""
    # インポートができなかった場合の例外処理
    begin
      User.create!(list)
      puts ""インポート完了!!""
    rescue ActiveModel::UnknownAttributeError => invalid
      puts ""インポートに失敗：UnknownAttributeError""
    end
  end
end
```

# まとめ
CSVインポートは現場でもよく使うとても重要な機能です。

これを実装できるようになると、面接でも大きなアピール材料になります。

ぜひ、なんども繰り返し復習して、どんなにたくさんのデータが入っているCSVでもインポート処理を書けるようにして見てください。

自分でCSVデータを作って機能を実装する練習をするのもいいですね。

お疲れ様でした！",2018-11-07 05:02:20 UTC,2018-11-08 12:58:56 UTC
33,Ruby on Rails,Rakeタスク,"# Rakeタスク
アプリケーションを起動せず、行いたい処理をCUI（コマンドプロンプトやターミナル）から実行できます。CSVデータのインポートなど、サーバーを起動せず任意の処理を実行する際にこの機能がよく利用されます。

## タスクを定義しよう！
今回は、CSVデータをデータベースへ登録するアプリを元に、Rakeタスクの実装について学んでいきましょう。まずは、実装対象となるアプリを立ち上げます。以下のコマンドを入力してください。

```
rails new rake_task_sample
```

アプリが作成できたら、アプリのディレクトリに移動しましょう。

```
cd rake_task_sample
```

移動ができたら、アプリに対応するデータベースを作成します。ちなみに、対象となるデータベースが起動してなければデータベースの作成はできないので、以下のコマンドを入力する前に、データベースを起動する事を忘れないようにしてください。自動起動の設定をしている場合は、何もしなくて大丈夫です。

```
bundle exec rake db:create
```

データベースがうまく作成されると、以下のような表示が出ます。（多少違っていてもエラーが出なければ問題ないです）

```
Created database 'rake_task_sample_development'
Created database 'rake_task_sample_test'
```

きちんとアプリができているか心配な方は、`rails s`コマンドを実行し、初期画面が表示されるか確認しておくといいです。

```
rails s
```

さっそく、これからRakeタスクの実装に移ります。Railsでは、デフォルトで設定されているRakeタスクがあります。これらのタスクは、アプリを作成する際自動で作成されます。まずは既存のタスクを確認してみましょう。以下のコマンドをターミナルに入力してください。

```
rake -T
```

そうすると現在のアプリに定義されているタスク一覧が表示されます。自分が定義したタスクを確認したい場合は、`rake -T`コマンドを利用して確認するようにしましょう。

```
rake about                              # List versions of all Rails frameworks and the environment
rake active_storage:install             # Copy over the migration needed to the application
rake app:template                       # Applies the template supplied by LOCATION=(/path/to/template) or URL
rake app:update                         # Update configs and some other initially generated files (or use just update:configs or u...
rake assets:clean[keep]                 # Remove old compiled assets
rake assets:clobber                     # Remove compiled assets
rake assets:environment                 # Load asset compile environment
rake assets:precompile                  # Compile all the assets named in config.assets.precompile
rake cache_digests:dependencies         # Lookup first-level dependencies for TEMPLATE (like messages/show or comments/_comment.html)
rake cache_digests:nested_dependencies  # Lookup nested dependencies for TEMPLATE (like messages/show or comments/_comment.html)
rake db:create                          # Creates the database from DATABASE_URL or config/database.yml for the current RAILS_ENV ...
rake db:drop                            # Drops the database from DATABASE_URL or config/database.yml for the current RAILS_ENV (u...
rake db:environment:set                 # Set the environment value for the database
rake db:fixtures:load                   # Loads fixtures into the current environment's database
rake db:migrate                         # Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)
rake db:migrate:status                  # Display status of migrations
rake db:rollback                        # Rolls the schema back to the previous version (specify steps w/ STEP=n)
rake db:schema:cache:clear              # Clears a db/schema_cache.yml file
rake db:schema:cache:dump               # Creates a db/schema_cache.yml file
rake db:schema:dump                     # Creates a db/schema.rb file that is portable against any DB supported by Active Record
rake db:schema:load                     # Loads a schema.rb file into the database
rake db:seed                            # Loads the seed data from db/seeds.rb
rake db:setup                           # Creates the database, loads the schema, and initializes with the seed data (use db:reset...
rake db:structure:dump                  # Dumps the database structure to db/structure.sql
rake db:structure:load                  # Recreates the databases from the structure.sql file
rake db:version                         # Retrieves the current schema version number
rake dev:cache                          # Toggle development mode caching on/off
rake initializers                       # Print out all defined initializers in the order they are invoked by Rails
rake log:clear                          # Truncates all/specified *.log files in log/ to zero bytes (specify which logs with LOGS=...
rake middleware                         # Prints out your Rack middleware stack
rake notes                              # Enumerate all annotations (use notes:optimize, :fixme, :todo for focus)
rake notes:custom                       # Enumerate a custom annotation, specify with ANNOTATION=CUSTOM
rake restart                            # Restart app by touching tmp/restart.txt
rake routes                             # Print out all defined routes in match order, with names
rake secret                             # Generate a cryptographically secure secret key (this is typically used to generate a sec...
rake stats                              # Report code statistics (KLOCs, etc) from the application or engine
rake test                               # Runs all tests in test folder except system ones
rake test:db                            # Run tests quickly, but also reset db
rake test:system                        # Run system tests only
rake time:zones[country_or_offset]      # List all time zones, list by two-letter country code (`rails time:zones[US]`), or list b...
rake tmp:clear                          # Clear cache, socket and screenshot files from tmp/ (narrow w/ tmp:cache:clear, tmp:socke...
rake tmp:create                         # Creates tmp directories for cache, sockets, and pids
rake yarn:install                       # Install all JavaScript dependencies as specified via Yarn
```

それではまず、Rakeタスクの処理を記述するファイルを作成します。Rakeタスクのファイルを作成するためには、ターミナルから以下のコマンドを実行します。今回は例なので、実際には入力しなくて大丈夫です。

```
rails g task task_name
```

`task_name`は、自分の好きな名前を指定することができます。どういう処理を実行するタスクなのか一目でわかるような名前をつけてあげると、後々タスク管理が楽になります。

### タスク定義の練習
まずは肩慣らしに、`Hello!!`などの簡単な挨拶を表示するタスクを作成しましょう。タスク名は`greet`にします。

```
rails g task greet
```

成功すると、以下の文が表示されます。

```
create  lib/tasks/greet.rake
```

`rails g task greet`コマンドを実行すると、`lib/tasks`に`greet.rake`という名前のファイルが作成されます。また、作成されたファイルには、自動で以下のようなコードが作成されています。

```ruby
namespace :greet do
end
```

では、作成したタスクファイルに、タスクとして行いたい処理を書いていきましょう。タスクは、基本的に以下のような構成要素になっています。`4. 名前空間`に関しては、後でご説明するので今は気にしなくて大丈夫です。

1. タスクの説明
2. タスクの名前
3. 実行したい処理
4. 名前空間

```ruby
# 名前空間
namespace :greet do
  # タスクの説明 desc => description（説明）
  desc """"
  # task_name => タスクの名前
  task task_name: :environment do
    # 実行したい処理を記述する場所
  end
end
```

descは`description`のことで、日本語でいうと「説明」という意味です。つまり、「どういうタスクを行うのか?」という説明をそこに書くというわけですね。そして、`task_name`がタスクの名前になります。どういう処理を行うタスクなのか分かりやすい名前をつけてあげると、後々タスクが増えた時にも混乱しなくて済みます。

では、`Hello World!!`を表示するだけの簡単なタスクを作成してみましょう。ファイル内の、好きな場所に以下のコードを記述しましょう。

```ruby
namespace :greet do
  desc ""Helloを表示するタスク""
  task say_hello: :environment do
    puts ""Hello!!""
  end
end
```

定義したタスクがきちんと表示されるか確認してみましょう。

```
rake -T
```

以下のような名前のタスクが存在すれば定義は成功です。

```
rake greet:say_hello                    # Helloを表示するタスク
```

確認ができたら、そのタスクを実行してみましょう。

```
rake greet:say_hello
```

以下のような表示になれば成功です。

```
Hello!!
```

## 名前空間について
簡単なタスクだけなら、ここまでで行ったやり方でも充分管理が可能なのですが、現場では目的が一緒でも名前を区別したいタスクが複数存在するときがあります。例えば、「データベースにCSVデータを登録する」という目的は同じでも、「ユーザーデータを登録するタスク」と「商品データを登録するタスク」を定義する場合です。この場合、いろんな目的を持ったタスクが大量に存在していたらどうなるでしょう？きっと混乱するのではないでしょうか？

そのような場合、それぞれのタスクをグループ分けできると、簡単に管理することができて便利です。そして、そのような実装を実現する時に便利なのが`名前空間（namespace）`なのです。

タスクは、名前空間を利用することで大まかなグループ分けを行い、管理することができます。ではさっそく、`名前空間（namespace）`の使い方をみていきましょう。

```ruby
namespace :namespace_name do

	task task_name1: :environment do
    # 実行したい処理
	end

  task task_name2: :environment do
    # 実行したい処理
  end
end
```
- namespace_name => 任意の名前空間
- task_name1, 2 => 任意のタスク名

この名前空間を利用して、挨拶を行うタスクと、簡単な計算を行うタスクをグループ化します。

```ruby
# greetという名前空間 => 挨拶をするタスクを定義
namespace :greet do

  desc ""Goodbyeを表示するタスク""
  task say_goodbye: :environment do
    puts ""Goodbye""
  end

  desc ""Helloを表示するタスク""
  task say_hello: :environment do
    puts ""Hello!!""
  end

end

# cgreet_when_datingという名前空間 => デート時の挨拶をするタスクを定義
namespace :greet_when_dating do

  desc ""容姿を褒める""
  task praise_appearance: :environment do
    puts ""You are beautiful!!""
  end

  desc ""ファッションを褒める""
  task praise_fashion: :environment do
    puts ""That's fashionable!!""
  end

end
```

定義したタスクがきちんと表示されるか確認してみましょう。

```
rake -T
```

以下のような表示がされていれば定義成功です。タスク名が`namespace`に紐づいた名前でグループ分けされていることが確認できます。

```
rake greet:say_goodbye                    # Goodbyeを表示するタスク
rake greet:say_hello                      # Helloを表示するタスク
rake greet_when_dating:praise_appearance  # 容姿を褒める
rake greet_when_dating:praise_fashion    # ファッションを褒める
```

確認ができたら、定義したタスクをどれか実行してみましょう。

```
rake greet_when_dating:praise_fashion
```

出力結果

```
That's fashionable!!
```

## CSVインポートのRakeタスクを定義
では、これからCSVデータを登録するタスクを実装していきましょう。まずは、データを格納するためのテーブルを作成する必要があるので、モデルを作成し、マイグレーションファイルを実行します。まずは、以下のコマンドを実行しましょう。

```
rails g model user
```

以下のような表示がされていれば成功です。

```
invoke  active_record
create    db/migrate/20180812021247_create_users.rb
create    app/models/user.rb
invoke    test_unit
create      test/models/user_test.rb
create      test/fixtures/users.yml
```

モデルの作成が完了したら、次にマイグレーションファイルの編集をします。今回は、ユーザーの名前、年齢、住所を格納するテーブルを作成したいので、以下のようにファイルを編集します。

```ruby
class CreateUser < ActiveRecord::Migration[5.0]
  def change
    create_table :user do |t|
      t.string :name
      t.integer :age
      t.string :address
      t.timestamps
    end
  end
end
```

マイグレーションファイルの編集が終わったら、以下のコマンドを実行しましょう

```
bundle exec rake db:migrate
```

無事にテーブルが作成できたら、次にrakeファイルを作成します。名前は`import_csv`にしてください。

```
rails g task import_csv
```

以下のような表示がされれば成功です。

```
create  lib/tasks/import_csv.rake
```

`rails g task import_csv`を実行すると、`lib/tasks`に`import_csv.rake`が作成されます。デフォルトでは、以下のようなコードが記述されています。

```ruby
namespace :import_csv do
end
```

それでは、いよいよCSVインポートの機能をRakeタスクに記述していきます。`import_csv.rake`に、以下のコードを記述してください。

```ruby
# CSVファイルを扱うために必要
require 'csv'

# 名前空間 => import
namespace :import_csv do
  # タスクの説明
  desc ""CSVデータをインポートするタスク""

  # タスク名 => users
  task users: :environment do
    # インポートするファイルのパスを取得
    path = File.join Rails.root, ""db/csv_data/csv_data.csv""
    # インポートするデータを格納するための配列
    list = []
    # CSVファイルからインポートするデータを取得し配列に格納
    CSV.foreach(path, headers: true) do |row|
      list << {
          name: row[""name""],
          age: row[""age""],
          address: row[""address""]
      }
    end
    puts ""インポート処理を開始""
    # インポートができなかった場合の例外処理
    begin
      User.create!(list)
      puts ""インポート完了!!""
    rescue ActiveModel::UnknownAttributeError => invalid
      puts ""インポートに失敗：UnknownAttributeError""
    end
  end
end
```

記述が終わったら、きちんと定義されているか確認しましょう。

```
rake -T
```

以下のような表示がされれば、タスクはきちんと定義されています

```
rake import_csv:users                     # CSVデータをインポートするタスク
```

次に、データを投入するためのCSVファイルを保管するディレクトリを作成しましょう。 `db` ディレクトリの中に `csv_data` ディレクトリを作成し、その中にCSVファイル `csv_data.csv` を作成します。

作成が完了したら、CSVファイルに以下の記述をしてください。

ちなみに、CSVとは `Comma Separated Value` の略で、Comma（カンマ）で値を区切ったデータ形式のことを指します。

```
name,age,address
hogehoge1,11,hogehoge1
hogehoge2,22,hogehoge2
hogehoge3,33,hogehoge3
hogehoge4,44,hogehoge4
hogehoge5,55,hogehoge5
```

それでは、Rakeタスクを実行するため、ターミナルに以下のコマンドを入力しましょう。

```
rake import_csv:users
```

これでデータベースへの登録ができれば、実装は完了です。 `rails c` でRails環境のコンソールを立ち上げ、以下のコードを入力してデータがきちんと投入されているか確かめてください。

```
rails c
```

ユーザーのデータが存在するかどうかを確かめるため、以下のコマンドを入力しましょう。

```
User.all
```

ユーザーのデータが表示されれば、データはきちんとインポートされています。

```
User Load (0.4ms)  SELECT  ""users"".* FROM ""users"" LIMIT $1  [[""LIMIT"", 11]]
=> #<ActiveRecord::Relation [#<User id: 1, name: ""hogehoge1"", age: 11, address: ""hogehoge1"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 2, name: ""hogehoge2"", age: 22, address: ""hogehoge2"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 3, name: ""hogehoge3"", age: 33, address: ""hogehoge3"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 4, name: ""hogehoge4"", age: 44, address: ""hogehoge4"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">, #<User id: 5, name: ""hogehoge5"", age: 55, address: ""hogehoge5"", created_at: ""2018-08-12 02:45:05"", updated_at: ""2018-08-12 02:45:05"">]>
```

## トランザクション制御
トランザクションとは、データベースへの変更を反映させるタイミングを制御するものです。なぜわざわざこういうことをするのかというと、データの整合性を保障するためです。わかりやすくするために、銀行でのお金の取引を例に考えて見ましょう。

例えば、AさんがBさんにお金を送金するとします。

1. Aさん => Bさんに送金する
2. Bさん => Aさんからお金を受け取る

このとき、Aさんの口座からお金が引かれてデータベースに変更が反映された後に、Bさんの口座のお金を増やす処理で失敗したとします。そうすると、以下のような状態になります。

1. Aさん => 貯金額減った
2. Bさん => お金振り込まれない

Aさんの貯金額は減っているにも関わらず、Bさんにはちゃんと送金されていないのはとても困りますね。その状態を解決するのがトランザクション制御なのです。この場合、処理1と2が完了するまでデータベースに変更を反映させないようにすれば、処理が成功した時だけデータベースが変更されるようになります。そうすれば、送金した金額と受け取った金額の不整合が無くなり、余計なトラブルを防ぐことができます。

### トランザクション制御の実装
それではさっそく、Railsにトランザクション制御の実装に取り掛かりましょう。基本的な書き方は以下の通りとなります。

```
モデル名.transaction do
  # 例外が発生する可能性のある処理
end
  # 正常に動作した場合の処理
rescue => e
  # 例外が発生した場合の処理
```

以下の記述を `import_csv.rake` に記述しましょう。

```ruby
# CSVファイルを扱うために必要
require 'csv'

# 名前空間 => import
namespace :import_csv do
  # タスクの説明
  desc ""CSVデータをインポートするタスク""

  # タスク名 => users
  task users: :environment do
    # インポートするファイルのパスを取得
    path = File.join Rails.root, ""db/csv_data/csv_data.csv""
    # インポートするデータを格納するための配列
    list = []
    # CSVファイルからインポートするデータを取得し配列に格納
    CSV.foreach(path, headers: true) do |row|
      list << {
          name: row[""name""],
          age: row[""age""],
          address: row[""address""]
      }
    end
    puts ""インポート処理を開始""

    begin
      User.transaction do
        # 例外が発生する可能性のある処理
        User.create!(list)
      end
      # 正常に動作した場合の処理
      puts ""インポート完了!!""
    # 例外処理
    rescue ActiveModel::UnknownAttributeError => invalid
      # 例外が発生した場合の処理
      # インポートができなかった場合の例外処理
      puts ""インポートに失敗：UnknownAttributeError""
    end
  end
end
```

## おまけ
以上で目的は達成できたのですが、インポート処理を行う際のターミナルの出力をわかりやすくために `colorize` というgemを導入しましょう。そうすると、処理結果を色で分けることができてより見やすくなります。以下のコードをGemファイルに追加しましょう。

```
gem 'colorize'
```

gemをインストールします。

```
bundle install
```

その後、出力する文字列に色を変えるためのメソッドを記述していきます。出力する文字を赤に変えたい場合は`""hoge"".red`、緑に変えたい場合は`""fuga"".green`と記述すればOKです。

```ruby
# CSVファイルを扱うために必要
require 'csv'

# 名前空間 => import
namespace :import_csv do
  # タスクの説明
  desc ""CSVデータをインポートするタスク""

  # タスク名 => users
  task users: :environment do
    # インポートするファイルのパスを取得
    path = File.join Rails.root, ""db/csv_data/csv_data.csv""
    # インポートするデータを格納するための配列
    list = []
    # CSVファイルからインポートするデータを取得し配列に格納
    CSV.foreach(path, headers: true) do |row|
      list << {
          name: row[""name""],
          age: row[""age""],
          address: row[""address""]
      }
    end
    # 文字を赤色で出力
    puts ""インポート処理を開始"".red
    # インポートができなかった場合の例外処理
    begin
      User.create!(list)
      # 文字を緑色で出力
      puts ""インポート完了!!"".green
    rescue ActiveModel::UnknownAttributeError => invalid
      # 文字を赤色で出力
      puts ""インポートに失敗：UnknownAttributeError"".red
    end
  end
end

```

これで`start to create users data`と`raised error`のメッセージが赤に、`completed!!`のメッセージが緑に表示されれば完了です。

処理的には何も変わらないのですが、メッセージがちょっとおしゃれに表示されるようになりました。

# まとめ
Rakeタスクは現場でも非常に使う機能であり、これを定義することで「CSVデータをインポートする」などの定期的に行うテスクの実行がとても楽になります。

実装できるようになれば、面接時にもとてもいいアピールになるので、ぜひ自分でCSVデータをいじって、色々なデータをインポートできるタスクを実装して見てください。

なれてきたら、登録するデータの件数を増やしてもいいかと思います。

お疲れ様でした！",2018-11-07 05:02:49 UTC,2018-11-07 05:02:49 UTC
34,Ruby on Rails,ログイン機能,"# ログイン機能
Webサイトでは、特定のページを観覧したりデータを登録したりする際に、ユーザーに制限を設けるためログイン機能をよく実装します。
Ruby on Railsを使用すれば、このログイン機能に関しても簡単に実装することができるので、ぜひやり方をマスターしてみてください。

まずは、アプリを作成します。

```
rails new devise_sample
```

アプリが作成できたら、アプリに対応するデータベースを作成しましょう。

```
bundle exec rake db:create
```

ログイン機能を実装するためには、`devise`というgemを使用します。
そのため、`Gemfile`に以下の内容を追記しましょう。

```ruby
gem 'devise'
```

`Gemfile`に追記が終わったら以下のコマンドを実行してgemをインストールします。

```
bundle install
```

gemがインストールできたら、ログイン機能を実装するために必要な設定をしていきましょう。
`devise`を使用するためには、Gemのインストールに加えてdevise専用のコマンドを利用して設定ファイルを作成する必要があります。
そのため、以下のコマンドを実行しましょう。

```
rails g devise:install
```

`devise`を使用する際のモデルの作成には通常の方法`rails g model`ではなく、`devise`専用のコマンドである`rails g devise user`を使用します。
これにより、ログイン機能に対応したモデルを作成することができます。

```
rails g devise user
```

`devise`に関連するモデルが作成できたら、migrationを実行してログイン機能に関連するテーブルを作成しましょう。

```
bundle exec rake db:migrate
```

マイグレーションファイルを実行し、ログイン機能に関連する`users`テーブルが作成できたら、`application.html.erb`にログイン状態によってナビゲーションバーの表示を変えるための記述を書きます。

|ログイン時|非ログイン時|
|---|---|
|ログアウト、トップに戻るリンクを表示|ログイン、新規登録リンクを表示|

それでは、以下のコードを`application.html.erb`に記述しましょう。

```
<!DOCTYPE html>
<html>
  <head>
    <title>LoginSample4</title>
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>

  <body>
    <!-- ここから -->
    <% if user_signed_in? %>
      <%= link_to ""ログアウト"", destroy_user_session_path, method: :delete %>
      <%= link_to ""トップ"", items_path %>
      <%= link_to '投稿画面へ', new_item_path %> 
    <% else %>
      <%= link_to ""ログイン"", new_user_session_path, class: 'post' %>
      <%= link_to ""新規登録"", new_user_registration_path, class: 'post' %>
    <% end %>
    <!-- ここまで -->
    <%= yield %>
  </body>
</html>
```

`application.html.erb`にナビゲーションバーが実装できたら、次は`item`モデルと`items`テーブルを作成しましょう。まずは`item`モデルの作成から。

```
rails g model item
```

`items`テーブルに`name`、`price`、`user_id`カラムを作成するための記述を追記します。`user_id`は、ログインユーザーのデータと紐づけるためのカラムです。

```ruby
class CreateItems < ActiveRecord::Migration[5.2]
  def change
    create_table :items do |t|
      # ここから
      t.string :name
      t.integer :price
      t.integer :user_id
      # ここまで
      t.timestamps
    end
  end
end
```

マイグレーションファイルを実行

```
bundle exec rake db:migrate
```

`db/seed.rb`にて、必要なデータをテーブルに投入するための処理を記入します。

```ruby
Item.create(name: ""熱狂のWebマーケティング"", price: 1500, user_id: 1)
Item.create(name: ""0秒シンキング"", price: 1200, user_id: 1)
Item.create(name: ""死ぬこと以外、けっこう平気。"", price: 1300, user_id: 1)
```

シードデータが用意できたら、以下のコマンドを実行し、データベースにシードデータを登録しましょう。

```
bundle exec rake db:seed
```

コマンドを入力したら、`rails c`でコンソールを立ち上げ、以下のコードを入力して、きちんとデータが登録されているか確認しましょう。

```
Item.all
```

`rails c`からデータを確認できたら`exit`で終了し、`config/routes.rb`にて商品一覧ページへのルーティングを設定します。

```ruby
root to: 'items#index'
resources :items
```

`views/layouts/application.html.erb`に追記が終わったら、`items`コントローラを作成します。

```
rails g controller items
```

`index`アクションを定義します

```ruby
class ItemsController < ApplicationController
  def index
    @items = Item.all
  end
end
```

ルーティングが設定できたら、`views`の中に`index.html.erb` を作成し、投稿一覧を表示するための記述を書きます。

```
<h1>購入商品一覧</h1>
<% if user_signed_in? %>
  <% @items.each do |item| %>
    <p><%= item.name %>：<%= item.price %></p>
  <% end %>
<% else %>
  <p>ログインしてください</p>
<% end %>
```

`devise`でログイン機能を実装すると、ログイン・サインアップ画面は自動的に生成されますが`views`の中には該当するファイルが存在しません。
そのため、今のままだとログイン画面に変更を加えることができません。

もし変更を加えたい場合は、deviseのコマンドを利用してビューファイルを生成する必要があります。
ログイン画面用のビューファイルを生成するためには、以下のコマンドを実行しましょう。

```
rails g devise:views
```

上のコマンドを実行すると、ビューファイルがたくさん生成されたかと思います。
ログイン画面周りのデザインを変更したい場合は、こちらのビューファイルを編集しましょう。

ただ、何も変更しなくても問題ないので、ここではデザインは割愛させていただきます。
何よりも優先して、サーバーサイドの実装を学ぶようにしましょう。

では次に、`items`コントローラに`new`アクションを追加します。

```ruby
class ItemsController < ApplicationController

  def index
    @items = Item.all
  end

  # newアクションを追加
  def new
    @item = Item.new
  end

end
```

`new.html.erb`に投稿フォームを作成

```
<%= form_for @item, method: :post do |f| %>
  <h1>ご購入商品の情報を入力</h1>
  <p>商品名：<%= f.text_field :name %></p>
  <p>値段：<%= f.text_field :price %></p>
  <input type=""submit"" value=""SENT"">
<% end %>
```

コントローラにcreateアクションを追加→入力したデータをモデルに保存する処理を書く

```ruby
class ItemsController < ApplicationController

  def index
    @items = Item.all
  end

  def new
    @item = Item.new
  end

  def create
    Item.create(name: item_params[:name], price: item_params[:price], user_id: current_user.id)
  end

  private

  def item_params
    params.require(:item).permit(:name, :price)
  end
end
```

create.html.erbファイルの編集

```
<h1>投稿が完了しました</h1>
<%= link_to '投稿一覧へ戻る', items_path %>
```

`items`コントローラを編集（ログインしていない時にはトップページにリダイレクトする）

```ruby
class ItemsController < ApplicationController
  before_action :move_to_index, except: :index

  def index
    @items = Item.all
  end

  def new
    @item = Item.new
  end

  def create
    Item.create(name: item_params[:name], price: item_params[:price], user_id: current_user.id)
  end

  def move_to_index
    redirect_to action: :index unless user_signed_in?
  end

  private

  def item_params
    params.require(:item).permit(:name, :price)
  end
end
```

次に、マイページが表示されるように実装していきます。
まずはルーティングを設定しましょう。

今回は、`users`というルーティングの中でも`show`アクションしか使わないので、`only: :show`と定義しています。
この定義により、`users`を利用したルーティングでは、`show`アクションにしか処理が流れません。

```ruby
Rails.application.routes.draw do
  root to: 'items#index'
  devise_for :users
  resources :items
  # 以下のルーティングを追加　onlyでshowアクションのみに制限
  resources :users, only: :show
end
```

次に、`users`コントローラを作成します。

```
rails g controller users
```

`users`コントローラに以下を記述します。

```ruby
class UsersController < ApplicationController
  def show
    @items = Item.where(user_id: current_user.id)
  end
end
```

詳細ページに商品一覧ページを表示します。

```
<% @items.each do |item| %>
  <p><%= item.name %>：<%= item.price %></p>
<% end %>
```

マイページへのリンクを`application.html.erb`に追記します。

```
<!DOCTYPE html>
<html>
  <head>
    <title>LoginSample4</title>
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>

  <body>
    <% if user_signed_in? %>
      <%= link_to ""ログアウト"", destroy_user_session_path, method: :delete %>
      <%= link_to ""トップ"", items_path %>
      <%= link_to '投稿画面へ', new_item_path %> 
      <!-- 以下の記述を追記 -->
      <%= link_to 'マイページへ', user_path(current_user.id) %> 
    <% else %>
      <%= link_to ""ログイン"", new_user_session_path, class: 'post' %>
      <%= link_to ""新規登録"", new_user_registration_path, class: 'post' %>
    <% end %>
    <%= yield %>
  </body>
</html>
```

次に、購入商品一覧に購入したユーザーのIDを表示させます。

`/views/items`の`index.html.erb`に会員Noを表示するため`<%= item.user.id %>`を追記しましょう。

```
<h1>購入商品一覧</h1>
<% if user_signed_in? %>
  <% @items.each do |item| %>
    <!-- item.user.idを追記 -->
    <p><%= item.name %>：<%= item.price %>：会員No.<%= item.user.id %></p>
  <% end %>
<% else %>
  <p>ログインしてください</p>
<% end %>
```

ただ、このままではエラーが出ます。
`item.user.id`というふうにデータを検索して表示するには、`users`テーブルと`items`テーブルのアソシエーションを設定する必要があります。

この設定により、`item.user.id`というふうに、データを検索する際の記述が簡単に書けるようになるわけです。

今回記述する`item.user.id`というコードは、「購入商品に紐づいたユーザーのidを表示する」という意味になります。

上のようなシンプルな記述だけで、商品に紐づいたユーザーのデータを`users`テーブルから検索し、全て表示することができるようになります。

それでは、`app/models/`ディレクトリにある`item.rb`を編集しましょう。

```ruby
class Item < ApplicationRecord
  # itemは1人のユーザーに所属する
  belongs_to :user
end
```

上のコードにある`belongs_to`は、モデルクラスに対応するデータがどのテーブルに所属しているのかを示しています。
この場合、`item`は1人の`user`に所有されるため、`belongs_to`となるわけです。
そのため、`user`というふうに単数形となっています。

`item.rb`が編集できたら`app/models`ディレクトリにある`user.rb`を編集しましょう。

```ruby
class User < ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable
  # userはたくさんのitemを持っている
  has_many :items
end
```

上のコードにある`has_many`は、モデルクラスがどのテーブルのデータを所有するのかを示しています。
この場合、`user`は複数の`item`を所有しているため`has_many`となるわけです。
そのため、`items`というふうに複数形となっています。

アソシエーションが設定できたら、あらためて商品一覧ページを表示しましょう。
商品情報と一緒に会員Noが表示されていれば成功です。

また、アソシエーションを設定することで、改善できるコードがもう2箇所あります。

それは、`users`コントローラとそれに紐づく`show.html.erb`に書かれたコードです。
まずは、`users`コントローラを以下のように編集しましょう。

```ruby
class UsersController < ApplicationController
  def show
    @user = User.find(current_user.id)
  end
end
```

`users`コントローラが編集できたら、次は`show.html.erb`のコードを以下のように編集します。

```
<!-- @user.itemsに変更 -->
<% @user.items.each do |item| %>
  <p><%= item.name %>：<%= item.price %></p>
<% end %>
```

これでだいぶ、実戦に近いコードになりました。
画面がきちんと表示されるか確認してみましょう。
改善前と同じようにデータが表示されていればログイン機能の実装は完了です。

ただ、もう少し改善できる部分もあります。
余裕のある人は、続きをやってみましょう。
ちょっと疲れた人は休憩を入れてください。

それでは、ログイン時にニックネームを登録できる機能を追加していきましょう。まずは、ニックネームを登録するカラムを作るためマイグレーションファイルを作成します。

```
rails g migration AddNicknameToUsers nickname:string
```

マイグレーションファイルを作成したら、それをもとにテーブルを作成します。以下のコマンドを実行しましょう。

```
bundle exec rake db:migrate
```

マイグレーションが実行できたら、ニックネームを登録するためのカラムを`app/views/devise/registrations/new.html.erb`に作成します。
以下のようにコードを編集しましょう。

```
<h2>Sign up</h2>
<%= form_for(resource, as: resource_name, url: registration_path(resource_name)) do |f| %>
  <%= devise_error_messages! %>

  <!-- ここから -->
  <div class=""field"">
    <%= f.label :nickname %> <em>(6 characters maximum)</em><br />
    <%= f.text_field :nickname, autofocus: true, maxlength: ""6"" %>
  </div>
  <!-- ここまで -->

  <div class=""field"">
    <%= f.label :email %><br />
    <%= f.email_field :email %>
  </div>

  <div class=""field"">
    <%= f.label :password %>
    <% if @validatable %>
    <em>(<%= @minimum_password_length %> characters minimum)</em>
    <% end %><br />
    <%= f.password_field :password, autocomplete: ""off"" %>
  </div>

  <div class=""field"">
    <%= f.label :password_confirmation %><br />
    <%= f.password_field :password_confirmation, autocomplete: ""off"" %>
  </div>

  <div class=""actions"">
    <%= f.submit ""Sign up"" %>
  </div>
<% end %>
```

ビューファイルの編集ができたら、ニックネームをデータベースに登録するためのストロングパラメータを設定します。
`devise`に関するストロングパラメータを設定するには、`application_controller.rb`を編集します。

それでは、以下のように`app/controllers/application_controller.rb`のコードを編集しましょう。

```ruby
class ApplicationController < ActionController::Base
  # 以下を追記
  before_action :configure_permitted_parameters, if: :devise_controller?

  # ここから
  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_up, keys: [:nickname])
  end
  # ここまで追記
end
```

上記の`devise_parameter_sanitizer.permit(:sign_up, keys: [:nickname])`の記述によって、`nickname`というパラメータがデータベースに登録できるようになります。
CRUD処理のところで実装した、ストロングパラメータと考え方は一緒ですね。

また、このストロングパラメータで登録の許可を出す判定は、全てのアクションよりも先に行われる必要があるため、`before_action`で`:configure_permitted_parameters, if: :devise_controller?`が実行されるように設定しているわけです。（`ApplicationController`はRailsで作成する全てのコントローラの親クラスなので`before_action`を定義すると全てのコントローラのアクションの前に実行されます）

ここまで実装できたら、動作を確認してみましょう。
新規登録時、ニックネームが登録できれば成功です。

ニックネームが登録できるようになったら、最後にもう一箇所だけ改善をしましょう。
本当にこれで最後です笑

今、商品一覧には購入者の会員Noが表示されているかと思います。
でも、これだとイマイチ誰が購入したのかわかりづらいですよね。

これを、購入したユーザーの名前が表示されるようにしましょう。
その際、ニックネームが無いユーザーの名前は表示しないように書き換えてあげます。

```
<h1>購入商品一覧</h1>
<% if user_signed_in? %>
  <% @items.each do |item| %>
    <!-- 以下に item.user.nickname if item.user.nickname.present? を追加 -->
    <p><%= item.name %>：<%= item.price %>：購入者　<%= item.user.nickname if item.user.nickname.present? %></p>
  <% end %>
<% else %>
  <p>ログインしてください</p>
<% end %>
```

`item.user.nickname if item.user.nickname.present?`は、もし、`item`に紐づいた`user`に`nickname`が存在しなかったら非表示にする記述になります。その判断をしているのが`present?`メソッドです。これを利用することにより、`nickname`がないときには何も表示されないように処理を書くことができます。

ただ、これだと購入者のニックネームがない場合はちょっと表示が不親切になってしまいます。

これだと、イマイチ実践的では無いので、「購入者のニックネームがある場合はニックネームを表示し、無い場合は会員Noを表示する」というように柔軟に対応できる処理を書いてみましょう。

その時にとても役に立つのが三項演算子です。
この三項演算子は、1行で2通りの処理を実装したい時に使います。
それでは、実際に処理を書いて見ましょう。

```
<h1>購入商品一覧</h1>
<% if user_signed_in? %>
  <% @items.each do |item| %>
    <!-- 三項演算子に修正 "" -->
    <p><%= item.name %>：<%= item.price %>：<%= item.user.nickname.present? ? ""購入者　#{item.user.nickname}"" : ""会員No.#{item.user.id}"" %></p>
  <% end %>
<% else %>
  <p>ログインしてください</p>
<% end %>
```

上のコードにおいて、三項演算子とは

```
item.user.nickname.present? ? ""購入者　#{item.user.nickname}"" : ""会員No.#{item.user.id}""
```

の部分です。
このように書くことによって`item.user.nickname.present?`の処理結果が`true`の場合は`""購入者　#{item.user.nickname}""`が表示され、`false`の場合は`""会員No.#{item.user.id}""`が表示されるようになります。

この三項演算子の部分を`if`文で書くと以下のようになります。

```
<p>
  <%= item.name %>：
  <%= item.price %>：
  <% if item.user.nickname.present? %>
    <%= ""購入者　#{item.user.nickname}"" %>
  <% else %>
    <%= ""会員No.#{item.user.id}"" %>
  <% end %>
</p>
```

これだと、行数が多くなる上に、`<p>`や`<%= %>`、`<%  %>`などの記述も入り、かなりコードを書くのがめんどくさくなります。
そしてなにより、読みにくいですね。
それがすっきりと1行にまとまるので、2つの条件分岐を行いたい場合は三項演算子の方が便利な時があります。

最後にもう一度。

```
<p><%= item.name %>：<%= item.price %>：<%= item.user.nickname.present? ? ""購入者　#{item.user.nickname}"" : ""会員No.#{item.user.id}"" %></p>
```

スッキリ！

以上がログイン機能の実装になります。
あとは、必要に応じてCRUD処理などを実装して見てください。
よりいっそう理解が深まるかと思います。

たくさんの学習項目があって最初は大変かと思いますが、ぜひ何度も繰り返し実装してみてください。
そのうち、すらすら理解できるようになります。
わからないところがあれば、また僕に聞いてください。

お疲れ様でした！


# デバッグ
`devise`を使用したログイン機能の実装に関して、以下のようなエラーが出た場合の対処法です。

```
NoMethodError in Devise::SessionsController#new
```

上記のようなエラーが出たら、一度、ログイン機能を実装するモデルの中で必要なさそうな記述を消して動作確認して見てください。
うまく動くようなら、モデルの中の記述が悪さをしています。

どの記述が悪影響を与えているのか調査して見ましょう。",2018-11-07 05:03:15 UTC,2018-11-12 03:59:18 UTC
35,Ruby on Rails,管理者画面,"# Active Admin
`Active Admin`とは、管理者画面を簡単に作成するためのGemです。これを利用することにより、データの作成、更新、削除を管理者画面から簡単に実行できるようになります。

そのため、ユーザーに見せる画面と、管理者用の画面を使い分けることができ、プログラミングができない人でもデータの更新が可能なWebサイトを構築することができます。

まずはじめに、Active Adminを実装するアプリを作成します。

```
rails new active_admin_sample
```

僕はデータベースに`PostgreSQL`を使用しているので、以下のコマンドを実行してアプリを立ち上げました。

```
rails new active_admin_sample -d postgresql
```

アプリが作成できたら、アプリのディレクトリに移動しましょう。

```
cd active_admin_sample
```

移動ができたら、アプリに対応するデータベースを作成するため、以下のコマンドを実行しましょう。また、データベースを作成する際はデータベースソフト（MySQLやPostgreSQL）が起動していないとエラーになるので注意が必要です。必ず起動してからコマンドを実行するようにしましょう。

```
bundle exec rake db:create
```

データを登録するテーブルを作成するため、テーブルに対応する`user`モデルを作成します。

```
rails g model user
```

model作成と同時にマイグレーションファイルも作成されるので、そのファイルを以下のように編集しましょう。今回は、`name,age,address`の３つカラムを作成します。そのため、`name`のデータ型を`string`、`age`のデータ型を`integer`、`address`のデータ型を`string`に設定します。

```ruby
class CreateDataTests < ActiveRecord::Migration[5.2]
  def change
    create_table :data_tests do |t|
      t.string :name
      t.integer :age
      t.string :address
      t.timestamps
    end
  end
end
```

マイグレーションファイルを実行し、データベースにテーブルを作成します。

```
bundle exec rake db:migrate
```

Active Adminは、ログイン用のgemである`devise`と組み合わせて使用する必要があります。`activeadmin`と`devise`の2つのgemをGemfileに追記しましょう。

```ruby
gem 'activeadmin'
gem 'devise'
```

gemをインストールします。

```
bundle install
```

gemのインストールが完了したら、Active Adminに必要なファイルをインストールします。

```
rails generate active_admin:install
```

マイグレートを実行します。

```
rake db:migrate
```

初期ユーザデータを作成するためシードファイルを実行します。

```
rake db:seed
```

※simple form を使用しているとエラーが出る：その場合は次のコマンドで解決

```
rails generate simple_form:install
```

サーバを起動します。

```
rails s
```

以下のURLにアクセスします。

[http://localhost:3000/admin](http://localhost:3000/admin)

以下のユーザでアクセスします。

```
User: admin@example.com
Password: password
```

Active Adminでは、`rails generate active_admin:resource model_name`というコマンドを実行することにより、`model_name`に対応した管理画面を作成することができます。今回は、`user`モデルに対する管理画面を作成したいので、以下のコマンドを実行しましょう。

```
rails generate active_admin:resource user
```

コマンド実行後、Userが管理画面に追加されていることを確認します。


## 管理画面の日本語化
`config`の中にある`application.rb`に`config.i18n.default_locale = :ja`を記述すると、管理画面を日本語にすることができます。ただし、各モデルのラベルは日本語化されません。その方法については、後述します。

```ruby
require_relative 'boot'
require 'rails/all'

Bundler.require(*Rails.groups)

module ActiveAdminSample
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 5.2
    # 以下の表記で管理画面を日本語化することができる
    config.i18n.default_locale = :ja
  end
end
```

## ラベルの日本語化
管理画面のラベルは、デフォルトでは英語になっています。それを日本語化するため、`config/locales`に`ja.yml`を追加し、必要に応じて設定したいラベルの日本語を追記しましょう。

```yml
ja:
 activerecord:
    models:
      user: ユーザー
    attributes:
      user:
        name: 名前
        age: 年齢
```

また、`rails-i18n`というgemを追加すると日付の部分も日本語にしてくれます。ちなみに、`rails-i18n`に書かれてある`i18n`とは`internationalization`の略で、国際化・多言語化を意味します。

```
gem 'rails-i18n'
```

```
bundle install
```

## 日本語化（必要な場合のみ）
locales直下にja.ymlを置く場合この記述は必要ありません。

```ruby
config.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}').to_s]
```

## まとめ
Active Admin は、管理画面を作成するために現場でも非常によく利用されているGemです。

これを活用することにより、高機能な管理画面が一瞬で作成できるようになるので、ぜひご自身のポートフォリオにも導入してみてください。

アプリの使いやすさが一段と上がります。",2018-11-07 05:03:39 UTC,2018-12-01 10:34:32 UTC
36,Ruby on Rails,検索機能,"# ransackとは
ransackはrails用の検索機能を実装するためのgemです。このgemを利用することにより、高機能なキーワード検索を実装できるようになります。

例えば、検索キーワードが入力された場合には、そのキーワードに紐づいたデータを取得し、検索キーワードが入力されていない場合には全件検索を行う、といった柔軟な検索機能が実装できるようになるわけです。

それではさっそく、`ransack`を導入してみましょう。以下のgemを`Gemfile`に追加します。

```ruby
gem 'ransack'
```

gemをインストールします。

```
bundle install
```

データを登録するためのデータベースを作成します。まずは、modelを作成しましょう。modelの名前はuserにしてください。

```
rails g model user
```

作成されたマイグレーションファイルを以下のように編集しましょう。

```ruby
class CreateUser < ActiveRecord::Migration[5.0]
  def change
    create_table :user do |t|
      t.string :name
      t.integer :age
      t.timestamps
    end
  end
end
```

マイグレーションファイルを編集したらマイグレートを実行し、テーブルを作成しましょう。

```
bundle exec rake db:migrate
```

次に、検索用のデータを投入します。今回は、`seed`の機能を利用してサンプルデータを作成します。以下のコードを`db/seeds.rb`に記入しましょう。

```
User.create(name: '斉藤', age: 35)
User.create(name: '田中', age: 21)
User.create(name: '佐藤', age: 32)
User.create(name: '山岸', age: 33)
User.create(name: '平', age: 26)
User.create(name: '加藤', age: 25)
```

`seeds.rb`に用意したデータをUsersテーブルへ投入します。以下のコマンドを実行しましょう。

```
bundle exec rake db:seed
```

データを投入したら、検索メソッドを実装するためのモデルを作成しましょう。今回作成するモデルのファイル名は`user_search.rb`です。`user_search.rb`ファイルの作成が終わったら、そのファイルに`UserSearch`クラスを定義し、`UserSearch`クラスに検索用の`execute`メソッドを定義しましょう。その際、`search_name`と`search_age`のインスタンス変数を定義します。その`execute`メソッドの中で、`ransack`の機能を利用します。

※`user`モデルに検索用のメソッドを実装する場合、インスタンス変数の名前（以下のコードにある`search_name`や`search_age`など）が`users`テーブルのカラム名と同じ値になると、データが登録できない状態になるので注意が必要です

```ruby
class UserSearch
  include ActiveModel::Model

  attr_accessor :search_name, :search_age

  def execute
    User.ransack(name_eq: @search_name, age_eq: @search_age).result
  end
end
```

モデルの編集が終わったら、次にルートを設定しましょう。`routes.rb`に以下のコードを追記してください。

```ruby
get '/users/search', to: 'users#search'
```

ルートの設定が終わったら、`users`コントローラに対応するアクションを記述します。そのため、まずは`users`コントローラを作成しましょう。以下のコマンドを実行してください。

```
rails g controller users
```

`users`コントローラが作成できたら、`search`アクションを追加しましょう。検索フォームから送信された`params`は`params_user_search`メソッドから受け取るようにします。

```ruby
def search
    user_search = UserSearch.new(params_user_search)
    @users = user_search.execute
end

private

def params_user_search
  params.permit(:search_name, :search_age)
end

```

`users`コントローラのアクションが定義できたら、次は画面の作成に移ります。検索機能を実装するには、検索ワードを入力するための画面が必要なので、次に、検索用の入力画面を作成しましょう。`users`ディレクトリに`search.html.erb`を作成し、以下のコードを記述しましょう。

```
<%= form_tag('/users/search', method: :get) do %>
  <%= label_tag :名前 %>
  <%= text_field_tag :search_name %>
  <%= label_tag :年齢 %>
  <%= text_field_tag :search_age %>
  <%= submit_tag '検索' %>
<% end %>
<table>
  <tbody>
    <thead>
      <tr>
        <th>名前</th>
        <th>年齢</th>
      </tr>
    </thead>
    <% @users.each do |user| %>
      <tr>
        <td><%= user.name %></td>
        <td><%= user.age %></td>
      </tr>
    <% end %>
  </tbody>
</table>
```

それでは、検索画面にアクセスし、動作確認をしましょう。サーバーを立ち上げた後、[http://localhost:3000/users/search](http://localhost:3000/users/search)にアクセスし、検索ワードを入力し、検索ボタンを押してみて下さい。

以上で検索機能の実装は終わりです。きちんとユーザーが検索できるか確かめて見ましょう。",2018-11-07 05:04:16 UTC,2018-11-12 04:00:34 UTC
37,Ruby on Rails,画像投稿機能,"# 画像アップロード
画像のアップロードに関しても、Webサイトではよく使用する機能なので実装できるようにしておきましょう。慣れれば5分くらいでできるようになります。

まず、画像をアップロードするために必要な`carrierwave`と`rmagick`というgemをインストールします。

```
gem 'carrierwave'
gem 'rmagick'
```

Gemfileへの記述が終わったら、gemをインストールします。

```
bundle install
```

## bundle install できなかった場合
もし、`bundle install`でエラーが出た場合は、以下のコマンドをターミナルから実行してください。エラーが出なかった人は、`つづき`からやってください。

まず、ImageMagick（バージョン7）をアンインストールします。

```
brew uninstall imagemagick
```

アンインストールが終わったら、 `ImageMagick（バージョン6）`をインストールします。

```
brew install imagemagick@6
```

`ImageMagick（バージョン6）`をインストールしたら、パッケージを有効化します。

```
brew link --force imagemagick@6
```

上記のコマンドを打ったら、再度`bundle install`をしてみましょう。

```
bundle install
```

これで解決できない場合は、神里に聞いてください。

## つづき
gemのインストールが終わったら、画像をアップロードする対象となるuserモデルを作成します。

```
rails g model user
```

userモデルが作成できたら、マイグレーションファイルの編集を行います。`users`テーブルに`image`カラムを追加し、画像をアップロードできるようにしましょう。

```ruby
class CreateUsers < ActiveRecord::Migration[5.2]
  def change
    create_table :users do |t|

      # 以下を追加
      t.text :image

      t.timestamps
    end
  end
end
```

マイグレーションファイルが編集できたら、実行して編集内容をテーブルに反映させましょう。

```
bundle exec rake db:migrate
```

マイグレーションが実行できたら、アップローダを作成します。

```
rails g uploader image
```

上のコマンドを実行すると`app/uploaders`に`image_uploader.rb`が作成されるので、その中を以下のように編集します。

```
class ImageUploader < CarrierWave::Uploader::Base
  include CarrierWave::RMagick
  storage :file
  process convert: 'jpg'
  # 保存するディレクトリ名
  def store_dir
    ""uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}""
  end
  # thumb バージョン(width 400px x height 200px)
  version :thumb do
    process :resize_to_fit => [400, 200]
  end
  # 許可する画像の拡張子
  def extension_white_list
    %W[jpg jpeg gif png]
  end
  # 変換したファイルのファイル名の規則
  def filename
    ""#{Time.zone.now.strftime('%Y%m%d%H%M%S')}.jpg"" if original_filename.present?
  end
end
```

アップローダーの編集が終わったら、画像をアップする対象となる`users`モデルに以下の記述を追加します。

```ruby
class User < ApplicationRecord
  # ここを追記
  mount_uploader :image, ImageUploader
end
```

`users`モデルの追記が終わったら`/config/routes.rb`に`users`のルーティングを設定します。

```ruby
Rails.application.routes.draw do
  # usersコントローラのnewアクションへ遷移するためのルーティング
  resoures :users
end
```

`users`モデルへの追記が終わったら`users`コントローラを作成します。

```
rails g controller users
```

`users`コントローラが作成できたら、新規投稿画面に対応する`new`アクションを定義します。

```ruby
class UsersController < ApplicationController
  # newアクション
  def new
    @user = User.new
  end
end
```

`new`アクションが定義できたら`/app/views/users`配下にある`/new.html.erb`に、ファイルをアップロードするフォームを作成します。

```
<%= form_for @user do |f| %>
  <%= f.file_field :image %>
  <%= f.submit %>
<% end %>
```

フォームが作成できたら、コントローラに`create`アクションを追加し、画像を`users`テーブルにアップロードできるようにします。

```ruby
def create
  User.create(user_params)
  # 投稿完了後、すぐに一覧表示画面へ遷移
  redirect_to :action => :index
end

private

def user_params
  params.require(:user).permit(:image)
end
```

`create`アクションが追加できたら、一覧表示画面に対応する`index`アクションを追加します。

```ruby
def index
  @users = User.all
end
```

`index`アクションが追加できたら、`/app/views/users`配下にある`/index.html.erb`に、画像を表示させるための記述を書きます。

```
<% @users.each do |user| %>
  <%= image_tag user.image_url(:thumb) %>
<% end %>
```

ここまできたら、実際に[http://localhost:3000/users/new](http://localhost:3000/users/new)にアクセスし、実際に画像の投稿と表示ができれば完了です。お疲れ様でした！",2018-11-07 05:04:42 UTC,2018-11-07 05:04:42 UTC
39,Ruby on Rails,テストコードの実装,"# RSpecの導入
RSpecとは、Ruby on Railsで作ったクラスやメソッドをテストし、品質を担保するためのテストフレームワークです。

このRSpecを使用してテストコードを書くことにより、コードを変更することによる予期せぬ不具合を防ぐことができます。

テストコードを書くのはめんどくさく感じるかもしれませんが、一度きちんとしたテストコードを書けば、自動で正確に早くテストを行うことができるため、簡単にプロダクトの品質を担保することができるようになります。

現場で働く上でも、このRSpecの理解は非常に重要ですので、ぜひご自身でもテストコードを実装できるようにしてください。

# 導入手順
まず、Railsアプリを作成します。

```
rails new rspec_sample
```

作成したアプリのディレクトリに移動します。

```
cd rspec_sample
```

アプリのディレクトリに移動できたら、データベースを作成します。

```
bundle exec rake db:create
```

アプリ作成できたら、テストの対象となるモデルクラスを作成します。以下のコマンドを実行しましょう。

```
rails g model user
```

モデルと同時にマイグレーションファイルが `db/migrate` に作成されるので、そのファイルをテキストエディタで開きましょう。

マイグレーションファイルを開いたら、以下のコードを追加してください。

```ruby
class CreateUsers < ActiveRecord::Migration[5.2]
  def change
    create_table :users do |t|

      # 以下の3行を追加
      t.string :name
      t.integer :age
      t.string :gender

      t.timestamps
    end
  end
end
```

マイグレーションファイルへの記述が終わったら、マイグレーションを実行します。

```
bundle exec rake db:migrate
```

次に、Gemfileを編集します。以下の記述をGemfileに追加しましょう。

```ruby
group :development, :test do
  gem 'rspec-rails'
end
```

Gemfileへの追記が終わったら、gemをインストールします。以下のコマンドを実行しましょう。

```
bundle install
```

gemがインストールできたら、RSpecの必要なファイルをインストールします。

```
bundle exec rails g rspec:install
```

上記のコマンドを実行するとファイルが作成され、ターミナルに以下のような内容が表示されます。

```
create  .rspec
create  spec
create  spec/spec_helper.rb
create  spec/rails_helper.rb
```

ファイルが生成できたら、まずは最初の状態でRSpecがきちんと動作するか確かめましょう。

```
bundle exec rspec
```

以下のような表示がでれば成功です。

```
No examples found.


Finished in 0.00052 seconds (files took 0.33436 seconds to load)
0 examples, 0 failures
```

動作が確認できたら、テスト対象となるモデルのspecを追加します。

```
bundle exec rails generate rspec:model User
```

上記のコマンドを実行すると `spec/models/user_spec.rb` が追加され、ターミナルに以下の内容が表示されます。

```
Running via Spring preloader in process 1706
      create  spec/models/user_spec.rb
```

それでは、テスト対象となる `User` モデルに `disp_name` メソッドを定義しましょう。今回は、こちらのメソッドの動作をテストしていきます。

```ruby
class User < ApplicationRecord

  attr_accessor :name

  def initialize(name:)
    self.name = name
  end

  def disp_name
    ""#{self.name}さん""
  end

end
```

それでは早速、定義したメソッドをテストしてみましょう。以下のようにテストコードを記述します。 また、最初から記述されている `pending ""add some examples to (or delete) #{__FILE__}""` は削除しても大丈夫です。

```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  it ""ユーザの名前が取得できること"" do
    user = User.new(name: ""satou"")
    expect(user.disp_name).to eq ""satouさん""
  end
end
```

テストコードが実装できたら、テストを実行してみましょう。

```
bundle exec rspec
```

以下のような記述になれば、テストは成功です。

```
Finished in 0.00435 seconds (files took 0.91794 seconds to load)
1 example, 0 failures
```

それでは次に、年齢によって表示する名前を変えるように、 `disp_name` を改善していきましょう。動きとしては、以下のようになります。

|年齢|表示|
|---|---|
|10歳以下|〜ちゃん|
|19歳以下|〜君|
|それ以外|〜さん|

それではまず、テストコードを実装し、期待値を先に決めましょう。

```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  describe ""名前の表示"" do
    it ""年齢1：ユーザーの名前が取得できること"" do
      user = User.new(name: ""satou"", age: 1)
      expect(user.disp_name).to eq ""satouちゃん""
    end
    it ""年齢15：ユーザーの名前が取得できること"" do
      user = User.new(name: ""satou"", age: 15)
      expect(user.disp_name).to eq ""satou君""
    end
    it ""年齢20：ユーザーの名前が取得できること"" do
      user = User.new(name: ""satou"", age: 30)
      expect(user.disp_name).to eq ""satouさん""
    end
  end
end
```

そして、そのままでRSpecを実行し、テストがミスすることを確認しましょう。

```
FF.

Failures:

  1) User 名前の表示 年齢1：ユーザーの名前が取得できること
     Failure/Error: expect(user.disp_name).to eq ""satouちゃん""

       expected: ""satouちゃん""
            got: ""satouさん""

       (compared using ==)
     # ./spec/models/user_spec.rb:7:in `block (3 levels) in <top (required)>'

  2) User 名前の表示 年齢15：ユーザーの名前が取得できること
     Failure/Error: expect(user.disp_name).to eq ""satou君""

       expected: ""satou君""
            got: ""satouさん""

       (compared using ==)
     # ./spec/models/user_spec.rb:11:in `block (3 levels) in <top (required)>'

Finished in 0.03215 seconds (files took 2.78 seconds to load)
3 examples, 2 failures

Failed examples:

rspec ./spec/models/user_spec.rb:5 # User 名前の表示 年齢1：ユーザーの名前が取得できること
rspec ./spec/models/user_spec.rb:9 # User 名前の表示 年齢15：ユーザーの名前が取得できること
```

それでは、このテストが全てパスするように `User` モデルの `disp_name` メソッドを定義していきましょう。

```ruby
class User < ApplicationRecord
  attr_accessor :name, :age

  def initialize(name:, age:)
    self.name = name
    self.age = age
  end

  # 年齢に応じて表示を変えられるように条件分岐を追加
  def disp_name
    if self.age > 19
      return ""#{self.name}さん""
    elsif self.age > 10
      return ""#{self.name}君""
    elsif self.age > 0
      return ""#{self.name}ちゃん""
    else
      return ""不正な数値です""
    end
  end
end
```

定義ができたら、テストを実行してみてください。

```
bundle exec rspec
```

以下のような表示になればテストは成功です。

```
...

Finished in 0.00964 seconds (files took 3.99 seconds to load)
3 examples, 0 failures
```

以下のように `let` を使用すると、パラメータの定義をまとめて記述することもできます。

```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  describe ""名前の表示"" do
    # パラメータをまとめて定義
    let(:params) {{name: ""satou"", age: 1}}
    let(:params2) {{name: ""satou"", age: 15}}
    let(:params3) {{name: ""satou"", age: 30}}

    # パラメータを使用してテスト
    it ""年齢1：ユーザーの名前が取得できること"" do
      user = User.new(params)
      expect(user.disp_name).to eq ""satouちゃん""
    end
    it ""年齢15：ユーザーの名前が取得できること"" do
      user = User.new(params2)
      expect(user.disp_name).to eq ""satou君""
    end
    it ""年齢20：ユーザーの名前が取得できること"" do
      user = User.new(params3)
      expect(user.disp_name).to eq ""satouさん""
    end
  end
end
```

`name` が `satou` というのは共通しているので、その部分のパラメータのみを事前に定義し、 `age` のみを後から追加することもできます。

```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  describe ""名前の表示"" do
    # 共通するパラメータを定義
    let(:params) {{name: ""satou""}}
    it ""年齢1：ユーザーの名前が取得できること"" do
      # merge!メソッドで後からパラメータを追加
      params.merge!(age: 1)
      user = User.new(params)
      expect(user.disp_name).to eq ""satouちゃん""
    end
    it ""年齢15：ユーザーの名前が取得できること"" do
      # merge!メソッドで後からパラメータを追加
      params.merge!(age: 15)
      user = User.new(params)
      expect(user.disp_name).to eq ""satou君""
    end
    it ""年齢20：ユーザーの名前が取得できること"" do
      # merge!メソッドで後からパラメータを追加
      params.merge!(age: 20)
      user = User.new(params)
      expect(user.disp_name).to eq ""satouさん""
    end
  end
end
```",,
38,Ruby on Rails,RailsアプリへのMarkdownの導入,"# RailsアプリにMarkdownを導入する方法
Ruby on RailsアプリでMarkdownを記述できるようにする方法をご紹介します。

この機能は、ほとんどHTMLを記述せずに画面を実装でき、コードもシンタックスハイライト付きで綺麗に表示できるため、プログラミングの教材作成にぴったりです。

# 導入手順
まずは、アプリを作成します。

```
rails new markdown_sample
```

アプリが作成できたら、 `cd` コマンドでアプリのディレクトリに移動します。

```
cd markdown_sample
```

移動ができたら、アプリに対応するデータベースを作成しましょう。

```
bundle exec rake db:create
```

データベースが作成できたら、以下の `gem` を `Gemfile` に加えます。

```ruby
# markdown
gem 'redcarpet', '~> 2.3.0'
# シンタックスハイライト
gem 'coderay'
```

`helpers` の中にある `application_helper.rb` に以下の記述を追記します。

```ruby
module ApplicationHelper
    require ""redcarpet""
    require ""coderay""

    class HTMLwithCoderay < Redcarpet::Render::HTML
        def block_code(code, language)
            language = language.split(':')[0] if language.present?

            case language.to_s
            when 'rb'
                lang = 'ruby'
            when 'yml'
                lang = 'yaml'
            when 'css'
                lang = 'css'
            when 'html'
                lang = 'html'
            when ''
                lang = 'md'
            else
                lang = language
            end

            CodeRay.scan(code, lang).div
        end
    end

    def markdown(text)
        html_render = HTMLwithCoderay.new(filter_html: true, hard_wrap: true)
        options = {
            autolink: true,
            space_after_headers: true,
            no_intra_emphasis: true,
            fenced_code_blocks: true,
            tables: true,
            hard_wrap: true,
            xhtml: true,
            lax_html_blocks: true,
            strikethrough: true
        }
        markdown = Redcarpet::Markdown.new(html_render, options)
        markdown.render(text)
    end
end
```

以上でRuby on RailsアプリへのMarkdownの導入が終わりです。これで、Markdownの記述をHTMLのタグに自動変換できるようになりました。

つまり、HTMLを使用せず、MarkdownでWebアプリケーションの画面が作れるようになったということです。

それでは、動作確認をしましょう。

まずは、コントローラとビューを作成します。以下のコマンドで一気に作成しましょう。

```
rails g controller users index
```

コントローラとビューが作成できたら、以下のコードを `/app/views/users/index.html.erb` に記述します。

```
<%=
  text =<<~TEXT
    # 大見出し
    ## 中見出し
    ### 小見出し
    \```
    puts ""hello""
    \```
  TEXT
 %>
<%= markdown(text).html_safe %>
```

記述が終わったら、 ルーティングを設定します。


```ruby
Rails.application.routes.draw do
  root to: 'users#index'
end
```

ルーティングの設定が終わったら、サーバーを起動させます。

```
rails s
```

サーバーが起動したら、以下のURLにアクセスしてください。

```
http://localhost:3000/
```

Markdownで表示されることが確認できたら実装は終了です。

# まとめ
MarkdownをRuby on Railsアプリに導入することで、かなり爆速で画面を作成することができるようになります。

プログラミング関連の教材を販売する際にも、Railsアプリを立ち上げてMarkdownで画面を作成すれば大幅に教材開発の効率を上げることができるので、ぜひ導入してみてください。

お疲れ様でした。",,
37,Ruby on Rails,RailsアプリへのjQueryの導入,"# RailsへのjQueryの導入
jQueryとは、JavaScriptの記述をより簡潔にするためのライブラリで、これにより動きのあるWebサイトを簡単に作れるようになります。

今回は、そのjQueryをRailsアプリに導入する方法について学んでいきましょう。

# 導入手順
`Gemfile` に以下のjQueryを導入するためのgemを追記します。

```
gem ""jquery-rails""
```

`jQuery` を読み込むため `application.js` に以下の内容を追記します。（上3行はすでに書かれているので追記しないでください）

```js
//= require activestorage
//= require turbolinks
//= require_tree .

// 以下の2行を追加
//= require jquery
//= require jquery_ujs
```

`application.js` を読み込む記述を `/app/views/layouts/application.html.erb` に追記しましょう。

```
<!DOCTYPE html>
<html>
  <head>
    <title>App</title>
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
    <%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track': 'reload' %>

    <!-- 以下を追記 -->
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>

  <body>
    <%= yield %>
  </body>
  
</html>
```

HTMLへの追記ができたら、jQueryが導入できているかを確かめましょう。 `id=""hoge""` の `p` タグの文字が赤になっていれば成功です。

```
<h1>Ajax#index</h1>
<p id=""hoge"">赤色になるよ</p>

<script>
  $(""#hoge"").css(""color"",""red"")
</script>
```",,
39,Ruby on Rails,React の導入,"# Reactとは
`React` とは、画面を構成するパーツ（コンポーネント）を作るためのライブラリです。

このReactを使用することにより、コンポーネント同士のデザインが不必要に影響し合うことなく、不具合の起きにくい画面を作ることができます。（CSSだと書き方によっては他の部分に不必要な影響を与えることがある）

# RailsアプリにReactを導入する
それでは早速、RailsアプリにReactを導入していきましょう。

まずは、Ruby on Railsアプリを作成するためのディレクトリを作成します。

```
mkdir react-sample
```

作成したディレクトリの中に移動します。

```
cd react-sample
```

Gemfileを生成するため、以下のコマンドを実行しましょう。

```
bundle init
```

Gemfileが生成できたら、それをテキストエディタで開き、ファイルに記述されている `gem ""rails""` の先頭の#を消します。

```ruby
# frozen_string_literal: true

source ""https://rubygems.org""

git_source(:github) {|repo_name| ""https://github.com/#{repo_name}"" }

gem ""rails""
```

Gemfileを編集したら、gemをインストールします。

```
bundle install --path vendor/bundle
```

gemのインストールが終わったら、アプリを立ち上げるために以下のコマンドを入力します。途中で上書きするか聞かれるので、その際は `Enter` を押してください。

```
bundle exec rails new . --webpack=react
```

処理が終了したら、Ruby on Railsアプリに必要なファイルやディレクトリが作成されているかを確かめるため、以下のコマンドを入力してください。

```
ls
```

以下のような実行結果になれば成功です。

```
Gemfile      app          db           package.json tmp
Gemfile.lock bin          lib          public       vendor
README.md    config       log          storage      yarn.lock
Rakefile     config.ru    node_modules test
```

次に、以下のコマンドを実行して `webpacker` をインストールします。

```
bundle exec rails webpacker:install
```

webpacker のインストールが完了したら 'react' をインストールします。

```
bundle exec rails webpacker:install:react
```

`bundle exec rails webpacker:install` と `bundle exec rails webpacker:install:react` の２つのコマンドを実行すると、binディレクトリに `webpack` と `webpack-dev-server` が追加されているのがわかるかと思います。そのため、これらのコマンドを利用できるようになります。

```
ls bin/
```

実行結果

```
bundle  rails  rake  setup  update  webpack  webpack-dev-server  yarn
```

それでは、アプリの動作確認をしてみましょう。サーバーを起動させます。

```
rails s
```

動作の確認ができたらRailsサーバーを停止させます。以下のコマンドを実行しましょう。

```
control + c
```

次に、画面を表示する処理を実装していきましょう。

まずは、ルーティングを定義します。

```ruby
Rails.application.routes.draw do
  root to: 'users#index'
end
```

ルーティングが定義できたら、コントローラを作成します。今回は、コントローラの作成と同時に `index` アクションと `views/index.html.erb` が同時に作成できるようにコマンドを実行してみましょう。こういうコントローラやビューの作り方もあるということを認識しておいてください。

```
bundle exec rails g controller users index
```

コントローラとビューが作成されたら、次に `app/views/layouts/application.html.erb` を編集しましょう。

```
<!DOCTYPE html>
<html>
  <head>
    <title>SampleApp</title>
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <!-- javascript_include_tagを以下のように変更 -->
    <%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
```

`application.html.erb` が編集できたら `app/javascript/packs/application.js` を編集しましょう。 `console.log('Hello World from Webpacker')` の下にコードを追記してください。

```js
console.log('Hello World from Webpacker')
// 以下の行を追加
require('./hello_react.jsx')
```

`hello_react.jsx` を変換（コンパイル）してjsファイルを作成します。拡張子である `jsx` は、 `JavaScript` の拡張言語のことで、この言語を使用することによって `JavaScript` 内でHTMLタグを記述することができるようになります。

では、早速 `jsx` を `js` にコンパイルしましょう。以下のコマンドを実行してください。

```
bin/webpack-dev-server
```

コマンドを実行したら、ターミナルの画面はそのままにし、新しくタブを立ち上げてRailsサーバーを起動しましょう。

ターミナルで新しくタブを立ち上げるためには以下のコマンドを実行します。

```
command + t
```

新しくタブが立ち上がったら、サーバーを起動します。

```
rails s
```

以下のURLにアクセスしてみましょう。

```
http://localhost:3000/
```

ブラウザで表示を確認してみましょう。

```
Users#index
Find me in app/views/users/index.html.erb

Hello React!
```

以上のような表示がされて入ればReactの導入は完了です。

# サンプルコード
ただ導入しても全然理解できないので、実際にコードを書いてReactの理解を深めていきましょう。

まず、コードを表示するための `div` タグを `/views/users/index.html.erb` に追記しましょう。その際、すでに記述されているコードは全て削除し、 `id` を `test` に指定します。

```
<!-- 以下のコードを追記 -->
<div id=""test""></div>
```

次に、 `app/javascript/packs/hello_react.jsx` を編集します。 `id` が `test` の要素を指定して、コンポーネントを表示させるように記述します。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

const Hello = props => (
  <div>Hello {props.name}!</div>
)

Hello.defaultProps = {
  name: 'David'
}

Hello.propTypes = {
  name: PropTypes.string
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <Hello name=""React"" />,
    // 以下のコードを編集
    document.getElementById('test'),
  )
})
```

次に、自分の名前を表示するようにしてみましょう。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

const Hello = props => (
  <div>Hello {props.name}!</div>
)

Hello.defaultProps = {
  name: 'David'
}

Hello.propTypes = {
  name: PropTypes.string
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    // 自分の名前を記述
    <Hello name=""Kamizato"" />,
    document.getElementById('test'),
  )
})
```

ちなみに、上のコードの中で以下の部分は `name` プロパティーの初期値を設定するために使用されます。

```js
Hello.defaultProps = {
  name: 'David'
}
```

試しに、 `<Hello name=""Kamizato"" />` の `name=""Kamizato""` の部分を削除してみましょう。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

const Hello = props => (
  <div>Hello {props.name}!</div>
)

Hello.defaultProps = {
  name: 'David'
}

Hello.propTypes = {
  name: PropTypes.string
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    // name を削除
    <Hello />,
    document.getElementById('test'),
  )
})
```

画面を確認すると、以下のように表示が変わっています。

```
Hello David!
```

# 変数の定義
変数を定義するには、 `const` を利用して以下のように記述します。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

// 変数nameを定義
const name = 'Tanaka'

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    // 変数nameを使用
    name,
    document.getElementById('test'),
  )
})
```

以下のように表示が変わっていることを確認してみてください。

```
Tanaka
```

# 変数の式展開
Reactでも、Rubyと同様に式展開することができます。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

const name = 'Tanaka'
// 変数elementを定義　nameを式展開
const element = <h1>Hello, {name}</h1>;

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    // elementを表示
    element,
    document.getElementById('test'),
  )
})
```

以下のように表示されることを確認してみてください。

```
Hello, Tanaka
```

# 連想配列
Reactでは、連想配列を使用して1つの変数に複数のデータを格納することができます。連想配列とは、Rubyでいう[ハッシュ](https://github.com/yoshitokamizato/rails_curriculum/blob/master/ruby/hash.md)のようなものです。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

// formatNameメソッドを定義する
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

# 条件分岐
Reactでも、もちろん条件分岐はあります。その際使用するのは、 Rubyと同じ `if` です。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  // 条件分岐 userのデータが存在するとtrue
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    element,
    document.getElementById('test'),
  )
})
```

以下のような表示になるか確認しましょう。

```html
Hello, Tanaka Kiyoshi!
```

上記のコードは、 `user` の中にデータが存在する場合の処理でした。次は、 `user` データが存在しない場合の処理も確かめてみましょう。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  // 条件分岐 userのデータが存在するとtrue
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    element,
    document.getElementById('test'),
  )
})
```

以下のような表示になるか確認しましょう。

```
Hello, Stranger!
```

# 時刻表示
時刻を表示するには以下のように記述します。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};

const element = (
  <div>
    <h1>Hello, {formatName(user)}!</h1>
    // 日付を表示するDateクラスを使用する
    <h2>It is {new Date().toLocaleTimeString()}.</h2>
  </div>
);

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    element,
    document.getElementById('test'),
  )
})
```

上記のコードを記述すると以下のように表示されます。

```
Hello, Tanaka Kiyoshi!
It is 17:39:48.
```

ただし、このままではリアルタイムで時刻表示することができないので以下のように書き換えます。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};

// 以下のクラスを定義
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, {formatName(user)}!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}


document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <Clock />,
    document.getElementById('test'),
  )
})
```

`function` の部分で `Clock` を複数呼び出すことで、簡単にコンポーネントを増やすこともできます。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};


class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, {formatName(user)}!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

function App() {
  return (
    <div>
      <Clock />
      <Clock />
      <Clock />
    </div>
  );
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <App />,
    document.getElementById('test'),
  )
})

```

# リンクを表示
HTMLと同じようにリンクを作ることができます。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};


class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, {formatName(user)}!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

// ボタンがクリックされた時のイベントを定義
function handleClick(e) {
  e.preventDefault();
  alert('The link was clicked.');
}

function App() {
  return (
    <div>
      <Clock />
      // ボタンを表示する記述
      <a href=""#"" onClick={handleClick}>
        Click me
      </a>
    </div>
  );
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <App />,
    document.getElementById('test'),
  )
})
```

# ボタンを表示
ボタンを表示するには以下のコードを追記します。

```js


import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'


function formatName(user) {
  if (user) {
    return user.firstName + ' ' + user.lastName
  }
  return 'Stranger'
}

const user = {
  firstName: 'Tanaka',
  lastName: 'Kiyoshi'
};


class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, {formatName(user)}!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

function handleClick(e) {
  e.preventDefault();
  alert('The link was clicked.');
}

// ボタンのコンポーネントを作成
class Button extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

function App() {
  return (
    <div>
      <Clock />
      <a href=""#"" onClick={handleClick}>
        Click me
      </a>
      // ボタンを表示
      <Button />
    </div>
  );
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <App />,
    document.getElementById('test'),
  )
})
```

# ボタンによって画面の表示を切り変える
ボタンを押すたびに「Please sign up.」と「Welcome back!」の表示が切り替わるように処理を書いて見ましょう。

これまでのコードは消して、新しく以下のようなコードを記述しましょう。

```js
import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = {isLoggedIn: false};
  }

  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

  handleLogoutClick() {
    this.setState({isLoggedIn: false});
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;

    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }
}

function UserGreeting(props) {
  return <h1>Welcome back!</h1>;
}

function GuestGreeting(props) {
  return <h1>Please sign up.</h1>;
}

function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {
    return <UserGreeting />;
  }
  return <GuestGreeting />;
}

function LoginButton(props) {
  return (
    <button onClick={props.onClick}>
      Login
    </button>
  );
}

function LogoutButton(props) {
  return (
    <button onClick={props.onClick}>
      Logout
    </button>
  );
}

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <LoginControl />,
    document.getElementById('test'),
  )
})

```

# リストの作成
リストを作成するときには以下のように記述します。

```js
import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <li key={number.toString()}>
      {number}
    </li>
  );
  return (
    <ul>{listItems}</ul>
  );
}

const numbers = [1,2,3,4,5];

document.addEventListener('DOMContentLoaded', () => {
  ReactDOM.render(
    <NumberList numbers={numbers} />,
    document.getElementById('test'),
  )
})
```

# まとめ
Reactは、画面を構築する上ではまさに最前線のスキルになります。フロントエンドのプログラマーになるにあたり、大きな武器となる技術なので、現場に入る前に慣れておくといいでしょう。

RubyやRuby on Railsに慣れたら、ぜひJavaScriptやReactの学習にも挑戦してみてください。

当コンテンツについても今後どんどん追記していきますが、とりあえず今はReactの基礎を押さえておくといいかと思います。

お疲れ様でした！",2018-11-07 05:05:16 UTC,2018-11-08 09:36:47 UTC